<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>如何写一手容易维护的代码 | Zonowry 的博客</title>

<meta name="generator" content="Hugo Eureka 0.9.3" />
<link rel="stylesheet" href="/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css">
<script defer src="/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="/js/fontawesome.min.35973bea57658ef0dd22ad59ea4642b6c8c67af62bed8659ac326d284ef285a6657cdbcf57d3b2910e7e992f2b20426e.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png">

<meta name="description"
  content="免责声明 程序员对抽象、设计可能会有不同的习惯。同样一个功能有人用发布订阅，有人用消息队列，他们都有自己的一套设计理念。最终是谁能说服谁的问题，哪一种方">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章列表",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"如何写一手容易维护的代码",
      "item":"/posts/software-system-thinks/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/software-system-thinks/"
    },
    "headline": "如何写一手容易维护的代码 | Zonowry 的博客","datePublished": "2024-01-01T00:00:00+00:00",
    "dateModified": "2024-01-01T00:00:00+00:00",
    "wordCount":  3382 ,
    "publisher": {
        "@type": "Person",
        "name": "WANG Chucheng",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "免责声明 程序员对抽象、设计可能会有不同的习惯。同样一个功能有人用发布订阅，有人用消息队列，他们都有自己的一套设计理念。最终是谁能说服谁的问题，哪一种方"
}
</script><meta property="og:title" content="如何写一手容易维护的代码 | Zonowry 的博客" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/posts/software-system-thinks/" />




<meta property="og:description" content="免责声明 程序员对抽象、设计可能会有不同的习惯。同样一个功能有人用发布订阅，有人用消息队列，他们都有自己的一套设计理念。最终是谁能说服谁的问题，哪一种方" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="Zonowry 的博客" />






<meta property="article:published_time" content="2024-01-01T00:00:00&#43;00:00" />


<meta property="article:modified_time" content="2024-01-01T00:00:00&#43;00:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="DDD" />





<meta property="og:see_also" content="/posts/project-thinking/" />




  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">Zonowry 的博客</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">首页</a>
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">如何写一手容易维护的代码</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2024-01-01</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>7分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="/categories/%E6%96%87%E7%AB%A0/" class="hover:text-eureka"
          >文章</a
        >
      
    </div>
  

  
</div>


  
  

  <h1 id="免责声明">免责声明</h1>
<p>程序员对抽象、设计可能会有不同的习惯。同样一个功能有人用发布订阅，有人用消息队列，他们都有自己的一套设计理念。最终是谁能说服谁的问题，哪一种方式都不是绝对正确的，就像本文一样。
内容有点偏意识流，不过总结的都是些很简单的东西。文中提到的诸多“本质”，应该会再写一篇来举例说明吧。</p>
<h1 id="人类智商受限">人类智商受限</h1>
<p>人类智商的难以理解庞大而复杂的软件系统，所以我们尝试用抽象来设计软件，设法以人类的智商也可以理解庞大的软件系统。</p>
<h2 id="抽象是什么">抽象是什么</h2>
<p>管理自己的磁盘时，都会建立类似 Work、Software、Temp、Repo &hellip;之类的文件夹。怎么分类文件夹最合理在这里不重要，重要的是分类文件夹前，肯定会进行的简单的<strong>设计</strong>。这个设计的思考过程我认为就是正在抽象。</p>
<p>举个不是很恰当的例子。我们不会为某一个 IDE 单独建立文件夹，来存放用它开发的代码文件。例如 <code>Intellij Projects</code>、<code>Visual Studio Projects</code> 。而是会尝试建立 <code>Projects</code>、<code>Repo</code>、<code>Workspace</code> 存放代码文件。这期间我们就是在抽象，把文件和具体的软件分离开，思考了这些文件的本质是”代码文件“，而非”某款软件的文件“。</p>
<p>抽象本质就是简化信息，是为了降低复杂度、是控制软件系统混乱程度的外在做功。</p>
<h2 id="从三层架构开始思考">从三层架构开始思考</h2>
<p>三层架构是一个很简单的，但抽象程度很高的模式。它可以解释大多数程序的组成：”有对外交互、有核心逻辑、有数据读写“。这就是它的高度抽象，把信息简化到了极致，所有程序都可以遵循三层架构模式写出来。三层本质是规范了代码边界，划分出三层边界：</p>
<ul>
<li>用户交互层：接收“用户”的输入，向“用户”输出处理结果。</li>
<li>核心逻辑层：只负责程序的核心“算法”，如何处理数据。</li>
<li>数据交互层：妥协层，内存实现不了持久化，抽象出一个数据读写层代替内存。</li>
</ul>
<p>代码设计的前期阶段，如何思考出一个模块的组成部分？三层架构给了我们一个优秀的示范。不需要思考功能的太多细节，<strong>全力以赴的简化功能的细节，简单直接的阐述功能的本质</strong>。</p>
<p>不过三层架构太抽象了，就像将“用户注册”抽象成“新增数据”，也就是相当于没有细节。如果只是从三层中学到了把代码按照交互、核心、读写划分的话，那实现细节还是会剪不断理还乱。只会套用三层架构范式，而不去思考功能本质的软件最终会难以维护，也许是屎山多是三层架构的原因（风评被害）。</p>
<h2 id="最小人力成本">最小人力成本</h2>
<p>简单的东西却蕴藏大设计，架构大道反而在最简单的三层之中。只要适当的简化信息，边界划分的足够合适，架构最终会形成一个个聚合，开始有了领域驱动的味道。可难点就是边界如何划分的足够合适，信息如何简化才算符合抽象。</p>
<p>现实世界复杂的，软件系统的复杂度也是熵增的主旋律。我们的不变的设计总会有一天会遇到冲击。<code>handleUser</code></p>
<p>不过结合实际工期限制，适当的抽象减轻维护难度就可以了。如果设计的非常全面，反而会给自己增加压力，延后工期。</p>
<h2 id="当谈起代码抽象">当谈起代码抽象</h2>
<p>要先认同抽象是一个很哲学的命题，百科对抽象的解释是找出事物的本质，剥离其它表象、杂质，最终形成一个“概念”。</p>
<p>然后务实的思考，抽象可以帮助我们简化代码，封装复用也好、继承多态也罢、接口定义先行。都是在“抽象”代码，以形成“某某功能”的概念，实现细节则是在具象（补完）这个概念。</p>
<p>使用第三方库时，遇到一些不清楚的方法，一般只需要在源码中找几个接口定义（注释）看看，或者阅读官网文档的 Api Reference 就能理解。这些库/框架都是“匠心之作”，它们的抽象单从版本更迭频率，就能看出来是很完美的，因为框架支持的功能很复杂。依靠抽象简化概念，修复 bug、新增功能时，我只需要确保我的“概念”还是不变的。这里“概念”就相当于一个依据，每次发版只需要确定这个依据不会发生改变。</p>
<p>接下来就是让代码变得“抽象”，</p>
<h1 id="信息隐藏">信息隐藏</h1>
<p>==三层架构的简化很直接==，我们一直在提的“简化”，都能联想到就是“抽象”，诚然，简化是一种抽象，抽象是一种简化。例如，什么叫真正的封装 - “信息隐藏”。</p>
<pre><code class="language-kotlin">// 3. 数据访问层
fun userDataAccess_GetUser(): User {
    return new User();
}

// 2.核心逻辑层
fun userBusiness_Login(): Boolean {
     val user = userDataAccess_GetUser()
     // 核心逻辑：只有周一允许登录
     return if(today() == '周一') true else false
}

// 1.用户交互层
fun userView_Login() {
    if(userBusiness_Login()) {
        return 'Redirect:/index.html'
    } else {
        // 错误的一种写法
        return &quot;登录失败，只有周一才能登录&quot;
        // 为什么上面的写法是错误的？
        // 因为核心逻辑层只返回了 false，没有说原因。
        // 用户界面层理应不知道原因，即使包含核心逻辑的 userBusiness_Login 方法也是你写的 
        return '登录失败，我不知道啥原因啊'
    }
}
</code></pre>
<p>例子中，代码的边界体现在「今天是周一才能登录系统」这个核心逻辑。用户界面层不应该知道这个细节。只根据核心逻辑层的返回值来做判断。即使核心逻辑层、用户交互层是同一个程序员写的代码，TA也应该克制（欺骗）自己，保持住代码的边界，即使返回给用户「只有周一才能登录」是更好用户体验。</p>
<p>简单来说就是，“我”忘记了核心逻辑层的代码，核心逻辑层只返回了一个 Boolean，指示登录是否成功。这样我的做法「登录失败，但我不知道原因」就很合理了。</p>
<h2 id="抽象的代码信息遮蔽">抽象的代码：信息遮蔽</h2>
<p>代码的边界似乎有一种大智若愚的感觉。有没有一种这不就是「接口类」 和 「实现类」嘛？就像“依赖接口而非依赖实现“一样。即使这段代码没有声明接口，我们是直接调用的方法（实现），但通过“欺骗”自己不知道实现细节，也有了类似调用接口的效果。或者反过来帮助我们理解接口的作用：隐藏实现细节。</p>
<p>可是明明知道实现细节，却又要隐藏实现细节。我们这么别扭的写代码是为了什么呢？抽象。</p>
<blockquote>
<p>不是鹰酱的「不听话就夹你！夹你！夹！你！」那种抽象呀。是 Abstract ，是 Interface。</p>
</blockquote>
<p>言归正传。大家一般接触到这样别扭的写法可能都是在写 <code>interface XxxxxService</code>，<code>class XxxxxServiceImpl : XxxxxService</code> 的时候。在改方法签名或新增方法的时候，都要改两个地方。感觉是很形式主义的，不明白为什么要这样做。有什么必要？这多数是因为开发角度、开发阶段不一样，如果只是看网上大家都这样做，那我也这样做。那必然会有这种“有必要吗”的想法。取决你你在写一个功能模块的时候，是先把所有接口声明完毕，敲定大体框架。还是先一个方法一个方法的渐进式实现。</p>
<p>当我们有这种想法时，说明我们对这个项目的潜力不报太大希望。如果我们对项目很看好，我们就会用心的考虑、设计：- 将来这些服务 <code>Service</code> 会不会开放给第三方？</p>
<p>当项目体量逐渐大起来，这样别扭的写法也。例如当我们思考以下问题时：</p>
<ul>
<li>这个接口的实现是哪个同事写的？
<ul>
<li>我不在意（除非要找个人背锅了）</li>
<li>我不在意（除非要找个人背锅了）</li>
</ul>
</li>
<li>这个接口的实现具体做了什么，怎么写的，用到了什么技术？
<ul>
<li>关我什么事。我只关注它可以达成什么效果，我要给它什么参数，它返回了什么。</li>
<li>关我什么事。我只关注它可以达成什么效果，我要给它什么参数，它返回了什么。</li>
</ul>
</li>
<li>接口调用出错了，这可咋办？
<ul>
<li>参数传的没问题，而且不是我写的？ 那就提 Issue 吧。</li>
<li>是我写的，或者已经修复了？那抽空升级下实现（依赖）的版本吧。</li>
<li>参数传的没问题，而且不是我写的？ 那就提 Issue 吧。</li>
<li>是我写的，或者已经修复了？那抽空升级下实现（依赖）的版本吧。</li>
</ul>
</li>
</ul>
<p>当然上边的例子更多是一种对接口的戏谑。来点实际的例子，就像我们写 <code>java</code>，不用去理解 <code>public void main()</code> 背后发生了什么，只需要知道这是程序的主入口。这就是设计 <code>java</code> 语言的人，进行了抽象，我们用就完事了。减轻了我们程序员的脑力消耗，也就减轻了能量消耗，随之减轻了碳排放，功劳不浅啊。</p>
<h2 id="抽象的边界契约精神">抽象的边界：契约精神</h2>
<p>边界和抽象，都聊过了。边界可以对“边界外”形成约定，抽象则可以让约定成为配置。</p>
<p>还可以在三层架构中发现一种代码边界，那就是用户交互层和客户端的「契约」或者说「约定」。</p>
<h2 id="三位一体的抽象">三位一体的抽象</h2>
<p>信息隐藏、抽象、封装、内聚、耦合&hellip;等等关于代码设计的术语，这些术语不只属于面向对象范式。不要陷入思考这些术语意义的陷阱，想方设法让代码变的抽象。而是让只需要凭借“码感”，写出你认为更容易理解的代码。</p>
<p>抽象应该是你潜意识的活动，绝不应该是很难理解的东西。应该是你在有了一些经验后，不知不觉间写出的代码。</p>
<h1 id="接着是贫血模型">接着是贫血模型</h1>
<p>到这里，对“代码边界”应该似懂非懂了一些吧。但 DDD 中的边界还要复杂一些，需要对业务建模，才能识别出代码边界，不过殊途同归。暂且将“边界”放到一边，随后我们将在 <code>DDD</code> 段落中继续探讨“边界”。</p>
<p>当我们潜意识中偏向写出这种代码，就说明你是写不出太离谱的屎山的。克制自己，欺骗自己。就像躺平了一样，我只知道这些，我也只能做到这些了。在现实生活中不算好的品质，在代码中就是恰到好处了，减轻了负担。</p>

</article>


      
        <div class="my-4">
    
    <a href="/tags/ddd/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#DDD</a>
    
</div>
      

      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="/posts/concurrent-programming/" class="block">Draft：我们仍未确定那刻所看见的变量的状态</a>
      
    </div>
  </div>


      



    </div>
    
      <div class="col-span-2">
        
        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页内容</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#抽象是什么">抽象是什么</a></li>
    <li><a href="#从三层架构开始思考">从三层架构开始思考</a></li>
    <li><a href="#最小人力成本">最小人力成本</a></li>
    <li><a href="#当谈起代码抽象">当谈起代码抽象</a></li>
  </ul>

  <ul>
    <li><a href="#抽象的代码信息遮蔽">抽象的代码：信息遮蔽</a></li>
    <li><a href="#抽象的边界契约精神">抽象的边界：契约精神</a></li>
    <li><a href="#三位一体的抽象">三位一体的抽象</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
      <div
        class=" bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"
      >
        <h3>相关</h3>
        
          <a href="/posts/project-thinking/" class="no-underline">关于思考一些简单代码设计来领略高大上架构这件事</a>
          <br />
        
      </div>
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text"> Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
  </body>
</html>
