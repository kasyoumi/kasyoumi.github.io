<!doctype html><html lang=zh dir=ltr><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>怎样安全的并发编程 | Zonowry 的博客</title><meta name=generator content="Hugo Eureka 0.9.3"><link rel=stylesheet href=https://blog.zonowry.com/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css><script defer src=https://blog.zonowry.com/js/eureka.min.fa9a6bf6d7a50bb635b4cca7d2ba5cf3dfb095ae3798773f1328f7950028b48c17d06276594e1b5f244a25a6c969a705.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload='this.onload=null,this.rel="stylesheet"'><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/base16/solarized-light.min.css media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js crossorigin></script>
<link rel=stylesheet href=https://blog.zonowry.com/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css media=print onload='this.media="all",this.onload=null'><script defer type=text/javascript src=https://blog.zonowry.com/js/fontawesome.min.8c77c7521b1f95ec2031c2a79f5c6a698aa4a0dba5ba649dfbc7f73994cddf3f494be6aac7e5724f35cbf72cfde09703.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ media=print onload='this.media="all",this.onload=null' crossorigin><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script><script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js integrity=sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0 crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=https://blog.zonowry.com/images/avatar_hu592978886036387a2c13d6a63e534067_442061_32x32_fill_box_center_3.png><link rel=apple-touch-icon sizes=180x180 href=https://blog.zonowry.com/images/avatar_hu592978886036387a2c13d6a63e534067_442061_180x180_fill_box_center_3.png><meta name=description content="我们仍未确定那天所见变量的状态"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"文章列表","item":"https://blog.zonowry.com/posts/"},{"@type":"ListItem","position":2,"name":"怎样安全的并发编程","item":"https://blog.zonowry.com/posts/how-to-do-safe-concurrent-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.zonowry.com/posts/how-to-do-safe-concurrent-programming/"},"headline":"怎样安全的并发编程 | Zonowry 的博客","datePublished":"2024-02-29T00:00:00+00:00","dateModified":"2024-02-29T00:00:00+00:00","wordCount":5481,"publisher":{"@type":"Person","name":"WANG Chucheng","logo":{"@type":"ImageObject","url":"https://blog.zonowry.com/images/avatar.png"}},"description":"我们仍未确定那天所见变量的状态"}</script><meta property="og:title" content="怎样安全的并发编程 | Zonowry 的博客"><meta property="og:type" content="article"><meta property="og:image" content="https://blog.zonowry.com/images/avatar.png"><meta property="og:url" content="https://blog.zonowry.com/posts/how-to-do-safe-concurrent-programming/"><meta property="og:description" content="我们仍未确定那天所见变量的状态"><meta property="og:locale" content="zh"><meta property="og:site_name" content="Zonowry 的博客"><meta property="article:published_time" content="2024-02-29T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-29T00:00:00+00:00"><meta property="article:section" content="posts"><meta property="og:see_also" content="https://blog.zonowry.com/posts/install-hyprland-on-arch-and-simple-beautify/"><meta property="og:see_also" content="https://blog.zonowry.com/posts/how-to-write-code-that-is-easy-to-maintain/"><meta property="og:see_also" content="https://blog.zonowry.com/posts/build-a-proxy-gateway-based-on-iptables-and-clash/"><body class="flex min-h-screen flex-col"><header class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"><div class="mx-auto w-full max-w-screen-xl"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=="Auto"||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName("html")[0].classList.add("dark")</script><nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0"><a href=/ class="me-6 text-primary-text text-xl font-bold">Zonowry 的博客</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i></button><div id=target class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20"><div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0"><a href=/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">首页</a>
<a href=/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item me-4">文章</a>
<a href=/thinks/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">碎碎念</a>
<a href=/firends/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 border-transparent me-4">友链</a></div><div class=flex><div class="relative pt-4 md:pt-0"><div class="cursor-pointer hover:text-eureka" id=lightDarkMode><i class="fas fa-adjust"></i></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open></div><div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions><span class="px-4 py-1 hover:text-eureka" name=Light>浅色</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>深色</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>自动</span></div></div></div></div><div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile></div></nav><script>let element=document.getElementById("lightDarkMode");storageColorScheme==null||storageColorScheme=="Auto"?document.addEventListener("DOMContentLoaded",()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","sun"),element.firstElementChild.classList.add("fa-sun")):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove("fa-adjust"),element.firstElementChild.setAttribute("data-icon","moon"),element.firstElementChild.classList.add("fa-moon")),document.addEventListener("DOMContentLoaded",()=>{getcolorscheme(),switchBurger()})</script></div></header><main class="grow pt-16"><div class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8"><div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12"><div class="bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"><article class=prose><h1 class=mb-4>怎样安全的并发编程</h1><div class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"><div class="me-6 my-2"><i class="fas fa-calendar me-1"></i>
<span>2024-02-29</span></div><div class="me-6 my-2"><i class="fas fa-clock me-1"></i>
<span>11分钟阅读时长</span></div></div><h2 id=引言>引言</h2><p>说到并发，首先会想到多线程。若只关注多线程如何使用，却对并发编程没有深入的了解，很容易在代码里挖坑，变成这个段子的模样：“从前有个程序员遇到了一个性能问题。他想，没事，我懂，用线程就好了。现他有在个两题了问“。</p><p>为了避免这种情况，我们该思考“为什么需要多线程，为什么 <code>js</code> 里没有多线程？”等诸类问题。将多线程看成是并发的一种手段，也就是让我们往下面 （the lower）走一点，越过线程理解并发编程。</p><blockquote><p>如果逻辑控制流在时间上重叠，那么它们就是<strong>并发的</strong>（concurrent）
—— 《CSAPP》</p></blockquote><h2 id=理论指导实践>理论指导实践</h2><p>分析 <code>thread（线程）</code>、<code>coroutine（协程）</code>、<code>reactive（反应式）</code>、<code>event/task queue（任务队列）</code>等各种并发<strong>手段</strong>。不讨论它们的用法、优劣，而是关注它们的的相似之处——它们实际都是通过编排、调度<strong>逻辑控制流</strong>实现的并发。所以只需要搞清楚它们是如何调度<strong>执行单元</strong>的，就掌握了核心<del>科技</del>。</p><blockquote><p>逻辑控制流，底层一点的理解是硬件电路形成的一组逻辑。应用级一点的解释是一个可以被执行的内容，可能是线程、协程、一个可观察对象 Observable、Subscription、FutureTask、Event Callback&mldr;&mldr;等等。不过用 <code>CSAPP</code> 书中的<strong>逻辑控制流</strong>表示一个可执行内容有点极简，所以下文就称之为<strong>任务</strong>或<strong>执行单元</strong>吧，<strong>代表一个可被执行的片段</strong>（you know it）。</p></blockquote><h3 id=抢占式调度>抢占式调度</h3><p>首先是最常见的抢占式调度，执行单元间呈<strong>竞争</strong>关系，A 任务与 B 任务互相争夺执行机会。最常见的例子是“操作系统内核利用 CPU 时钟中断，达成多线程并发“。每次中断都代表某个线程抢到了 CPU 时间片”。因为 CPU 中断是纳秒级的，实际效果是内核在飞快的切换执行单元以交错执行。提供一种所有执行单元在<strong>并行</strong>的假象。在多核心 CPU 下，内核的抢占式调度也足以实现真正的<strong>并行</strong>。</p><p>抢占式调度下，执行单元无法确定自己什么时候会被执行，且任何时刻都可能会被中断执行。反过来说，只要我们基于此特性，处理好执行单元的竞争与中断，就可以实现一个抢占式调度器。也可以看出抢占式调度的好处是不会存在独占情况——某个执行单元永远占用着 CPU。因为每个执行单元都有被执行的机会，就像在等红绿灯一样。</p><h3 id=协作式调度>协作式调度</h3><p>协作式调度可以引出一大堆技术，例如 <code>IO 多路复用</code> 、<code>迭代器</code>、<code>事件驱动</code> 等等。</p><p>它们都有一个点——主动让渡控制权，或者说主动挂起的（释放并等待）。A 任务与 B 任务可以在<strong>合适</strong>的时机<strong>主动</strong>让渡出控制权。特点是持有控制权的任务主动中断，~~抛开现实不谈（例如 CPU 中断），~~这也突出了协作式调度的优点与理念——“调度不会影响<strong>顺序性</strong>“。因为我们是主动让出的，继续执行时可以找到让渡时的节点来保证顺序性，也可以理解为调度器会帮我们将执行单元恢复到让渡前一刻的状态，然后就像没让渡过一样继续执行。</p><p>协作式调度，执行单元知道自己什么时候会让出，但同时对程序员也是<strong>无感知</strong>的，因为当再次拿到控制权时，协作式调度器可以保持顺序性<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。这个特性提高了程序员们的并发编程体验。于是出现了很多协作式调度框架。抽象的角度看，不论是 <code>Reactive Stream</code>，还是 <code>coroutine</code> ，在我看来都是协作式调度的不同实现。它们都有着执行单元可以主动挂起的特性，与其它执行单元<strong>协作式</strong>的完成逻辑。</p><h2 id=实践中的问题>实践中的问题</h2><p>是时候为线程正名一下了，虽然前面段落回避提及线程，但现在开始线程必不可少，因为线程作为系统内核最小的调度单位，实现<strong>并行</strong>基本<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>离不开线程。协程、反应式等用户态的并发模型到底还是跑在线程上的。</p><p>单线程的话，就不存在着并发编程中的问题，无非就是线程安全了。原因只有<strong>并发环境下访问共享可变的状态</strong>一种。但为什么<strong>共享状态</strong>这个操作会引起问题？因为数据读写不一致。为什么会读写不一致？需要搞清楚并发下计算机是如何读写状态的。</p><blockquote><p>专业一点的说共享状态就是<strong>竞态条件</strong>。也说明两个执行单元可能有某种依赖关系，它们需要协商好谁可以使用这个状态。</p></blockquote><h3 id=缓存一致性>缓存一致性</h3><p>假设计算机的内存<strong>非常快</strong>且<strong>非常大</strong>，那我们就不需要担心<strong>缓存一致性</strong>问题了，为什么？因为每次读取状态，都是最新的状态，这是纳秒级实时读写。<del>（最后说一次，时间要加速了）</del>，这是美好的未来。可现实世界的计算机是有极限的（<del>我不做电子计算机了！JOJO！</del>），计算机的妥协设计是每个 CPU 核心都有一块<strong>独立的</strong>非常快，但非常小的内存，称之为<strong>高速缓存</strong>；再加一块速度尚可（远不及 CPU 计算速度），但非常大的内存，它就是我们的内存条，称之为<strong>主内存</strong>。</p><p>两块内存特性互补，让数据读写不至于拖慢 CPU 计算。妥协的代价就是数据一致性问题，或者说数据可见性问题。因为 cpu 运行一个线程时，需要先从主内存读取数据拷贝到高速缓存里，之后就是 cpu 与高速缓存的时间了，期间 CPU 会适时的将高速缓存里的堆积数据刷写到主内存中。问题出在线程间可以共享数据，会牵扯到<strong>数据同步</strong>（<del>最小的分布式了吧？</del>），有数据同步就不可避免的有一致性问题了，与分布式、数据库领域的<strong>数据一致性</strong>大同小异。</p><p>高级语言为了避免我们太操心这些事情，抽象了运行时内存区域（堆栈、常量区、方法区&mldr;），然后设计了内存模型，负责线程间通信，保证线程间数据同步，线程空间隔离。让多线程容易使用，程序员们要操心的事情变少了（不用和系统底层打交道），但也也让线程间通信变的陷阱重重。</p><h3 id=读写有序性>读写有序性</h3><p>不考虑性能，假设不存在中间<strong>缓存</strong>，每个 CPU 核心实时读写主内存，可以保证所有线程共享数据的<strong>一致性</strong>。但这样能解决线程安全问题吗？还是不行，因为计算机并不会 <code>line by line</code> 的执行代码，因为计算机/虚拟机会在不影响语义的情况下，优化代码的执行顺序。也就是优化后应该与不优化执行的结果一致，称之为<strong>重排序</strong>。</p><p>想象<strong>多个线程</strong>只共享<strong>一个变量</strong>时，我们的假设确实有用——指令重排序对我们来说不会是问题。但<strong>多个线程</strong>共享<strong>多个变量</strong>时，指令重排序的情况就很复杂了。线程是独立的，无法确保另一个线程的重排序会不会影响。举个简单的例子，方便理解：</p><pre><code class=language-kotlin>var value: Int = 0;
var flag: Boolean = false;
​
fun init() {
	value = 8;
	flag = true;
}
​
fun getValue() {
	if (flag) {
		println(value);
	}
}


fun main() {
	// thread 1 可能会先执行 flag = true，后执行 value = 8
	thread { init(); } 
	// 在这钟情况下，thread 2 则有可能 print 0;
	thread { getValue() }
}
</code></pre><p>如果没有重排序，因为我们知道线程就算是抢占的，交错执行。但也不会造成 <code>print</code>
0 的情况，因为赋值 <code>value = 8</code> 是<strong>原子操作</strong>（下面介绍）。<del>2个线程，2个共享变量，非常简单代码，使我的大脑宕机，爱来自&mldr;..</del></p><p>真实的代码会更复杂，可见编译器和 CPU 很难确保<strong>重排序</strong>优化在<strong>多线程多共享</strong>的情况下不会出现异外结果。就像这个理论不该出现的 <code>print</code> 0，即使我们理解线程的交错执行，且阅读并人脑编译了代码可能的执行过程，但因为指令重排序的存在，这一切变得混沌。</p><h3 id=原子一致性>原子一致性</h3><p>进一步假设~~（现在是幻想时间）~~，不存在指令重排序，不存在缓存一致性问题，相当于 <code>java</code> 的 <code>volatile</code> 关键字的效果。线程安全问题还会存在吗？还是会存在，因为程序不仅有指令、数据，还有<strong>算法</strong>（<strong>逻辑</strong>）。</p><p>编排一系列指令形成逻辑，可以称之为<strong>算法</strong>或操作（<del>算法帅一点，所以下文统称算法</del>）。既然是一系列指令，那么每条指令都有可能会被系统内核中断或被其它并行的线程影响，导致算法结果不符合预期。而原子性的百科定义是：</p><blockquote><p>原文：<strong>线性一致性</strong>（Linearizability），或称<strong>原子一致性</strong>或<strong>严格一致性</strong>指的是程序在执行的历史中在存在可线性化点P的执行模型，这意味着一个操作将在程序的调用和返回之间的某个点P起作用。这里“起作用”的意思是被系统中并发运行的所有其他线程所感知。</p></blockquote><p>大概意思是如果某个指令被执行，其它线程一定会知道这个指令被某个线程执行了，就像单线程一样，等待执行的代码行可以感知到已执行的代码行。或者常见的理解基于「原子是不可再分割的最小物质」并发原子性就是「不可再打断的最小操作序列」。这个解释与<strong>数据库的原子性</strong>「要么全都成功，要么全都失败」异曲同工，当然细说还是有区别的，例如并发的原子性不会 <code>rollback</code> 。</p><p>我的解释是，如果一个算法执行过程中，即使被内核中断切换了线程，或存在共享状态的并行线程，也不会被影响结果。就可以说这个算法是<strong>线程安全</strong>的，也可以理解为算法不会被<strong>打断</strong>，具有原子性。</p><p>原子性我认为是比较容易理解的，因为非原子性算法造成的影响用户态可以很明显的感知到。例如两个线程同时执行 <code>i++</code> ，最后 <code>i</code> 的结果通常会小于预期值。</p><p>无论如何，这是最后一步了，不会继续假设了。只要保证原子性，就可以使线程同步，线程同步了，线程安全问题自然烟消云散。</p><h2 id=高速的安全并发>高速的安全并发</h2><p>步入正题，前文可得，只要我们灵活运用三大特性即可避免线程安全问题。不过我们并发初衷可不是为了安全，而是 fot the speed！速度！</p><p>《Java 并发编程实践》中写过，如何修复线程安全问题：</p><blockquote><p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复该问题：</p><ul><li>不在线程之间共享该状态变量</li><li>将该状态变量修改为不可变的变量</li><li>再访问该状态变量时使用同步</li></ul></blockquote><h3 id=串行编程>串行编程</h3><p>先看最简单的一种：<strong>在访问该状态变量时使用同步</strong>，也就是串行化线程了。</p><p>前文也提到「只要保证了原子性，就可以使线程同步」。可以总结出两种为线程添加原子性的主要方式：</p><ul><li><strong>原子指令</strong>：CPU 指令级别的<strong>原子操作</strong>。如大名鼎鼎的 <code>CAS - 比较并较换</code> 指令。</li><li><strong>信号量</strong>：是一种底层思想，以<strong>信号量的不变性</strong>实现出<strong>原子指令</strong>、<strong>线程锁</strong>。</li></ul><h4 id=原子指令><strong>原子指令</strong></h4><p>原子指令比较容易理解，就像定理一样。从 CPU 硬件级别限制了此指令不会被中断，一但执行，不可取消。</p><p>常见的 <code>CAS</code> 原子指令就是实现各种<strong>乐观锁</strong>的关键，因为 <code>CAS</code> 指令不可被中断，才能保证乐观锁自旋的检测与更新是线程安全的。例如 <code>AtomicInteger</code>，<code>MVVC</code></p><p><strong>原子指令</strong>在性能损耗上大大小于整块代码加锁，但使用场景上也比较受限。~~因为不如加锁一把梭简单。~~对于一段多线程代码，需要人脑编译来判断“仅依靠原子指令是否可以保证线程安全“，说多线程优化通常就是在说这个，依靠原子指令让你的线程锁（阻塞）变少。就像乐观锁做的一样，通过 <code>CAS</code> 指令，来应对多读少写的场景。<del>或者直接改变你的算法逻辑</del></p><h4 id=信号量><strong>信号量</strong></h4><blockquote><p>以提供互斥为目的的二元信号量常常也称为<strong>互斥锁</strong>（mutex）。
——《CSAPP》</p></blockquote><p>同步线程都知道用<strong>线程锁</strong>，常用的线程锁基于<strong>信号量</strong>的思想。使用二元<strong>信号量</strong>变量实现<strong>互斥锁</strong>的例子：</p><ul><li>执行线程前，首先获取信号量<ul><li>如果信号量为 <code>0</code> ，则挂起线程，等待重启，重启后继续判断信号量。</li><li>如果信号量为 <code>1</code> ，则立即返回，并 <code>- 1</code>，这将导致其它线程挂起，本线程执行。</li></ul></li><li>执行线程后（包括被中断），必须释放信号量：<ul><li>将信号量 <code>+ 1</code>，并尝试重启一个因为此信号量挂起的线程。</li></ul></li></ul><p>然后我的建议是不要在信号量、互斥量、自旋锁、乐观锁、悲观锁、互斥锁等等这些术语上浪费太多脑筋。信号量是底层的一种思想，各种锁都是基于这个思想实现的，只是互斥的级别不同，根据锁的用途对锁进行了概念上的分类。不用在名字上过于讲究。</p><h3 id=不可变变量>不可变变量</h3><p><strong>将该状态变量修改为不可变的变量</strong>，很容易理解的一种方式。说起来也很简单：你的共享变量不可变了，相当于只允许读取，必然就不涉及同步问题了。</p><p>做起来的话会很艰难，每个线程的数据都像快照一样。数据一致性的控制权回到了你的手里。需要你来编排数据的“流向”，进入什么数据，出来的会是什么，线程没有了<strong>副作用</strong>，线程的输出你可以预测，就像一条功能明确的加工流水线。</p><blockquote><p>副作用就是指不会对外界产生影响</p></blockquote><p>不可变变量，函数式的思想，一种优雅至极的方案，但会让你束手束脚，不过如果完美贯彻函数式，应该会很流畅，不过需要很高的脑力吧&mldr;不过尽量让变量不可变，从而让函数保持无副作用，是一种好习惯。</p><h3 id=分布式事务>分布式事务</h3><p>再来看好像最简单的一种：<strong>不在线程之间共享该状态变量</strong>。<del>作者本意应该不是让我们放弃。</del></p><p>其实联想一下，不共享状态，每个线程对于变量的当前正确值是没有感知的，把每个线程看作一个分布式节点，像不像分布式里的数据一致性问题？那瞬间就变的很复杂了。</p><p>不共享状态，但我们又需要访问该状态。只要我们可以接受短暂的线程不安全，退一步，就会有很多方案。可以参考分布式事务的一些成熟做法，例如<strong>最终一致性</strong>、<strong>两阶段提交</strong>等。~~不过这已经算脱离了线程安全话题了，算是数据设计了。~~简单的介绍一下吧，其实纯编程实现没太大意义，通常结合数据库、消息队列等中间件来实现。</p><ul><li><strong>最终一致性</strong>：两个线程执行时，拿到的是共享变量的副本，各自执行完成后，可能还有一个线程在不停的纠正数据。</li><li><strong>两阶段提交</strong>：每个线程执行完毕后，发出准备提交的通知。主线程收到所有线程<strong>都准备就绪</strong>后，允许各个线程进行提交。然后各个线程开始提交。</li></ul><p>本质上我们就是需要一些保险手段，在尽可能不影响线程效率的情况下，保障数据不出错。</p><h2 id=参考>参考</h2><ul><li><a href=https://jolestar.com/parallel-programming-model-thread-goroutine-actor/>并发之痛 Thread，Goroutine，Actor</a></li><li><a href=https://www.zhihu.com/question/296949412>既然CPU有缓存一致性协议（MESI），为什么JMM还需要volatile关键字？</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>可能会对 <code>rx</code> 的顺序性提出质疑，这里非指过程式一样的代码的编写顺序，例如容易理解的协程的顺序性，而是“可以较为容易”的预测代码执行的顺序。例如 <code>rx</code> 的 <code>obserable.flatmap().reduce().publishOn().map().tap()</code> 例子，还是可以预测出这段代码的整体顺序性的，只是操作符联合起来会很复杂，让人难以理解，不过还是可以说 <code>rx</code> 是有一定顺序性的，毕竟本质上是一个流处理，流的流转过程就是顺序。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>如果不把异步 IO看作一个特殊的“线程”，那将 IO 读写操作交由内核调度，注册回调后继续干活，变相实现了一个线程逻辑计算的同时，其它 IO 硬件也正在读写数据（如网卡），实现并行处理：一个IO硬件，一个CPU。虽然多数场景我们都是要挂起线程，等待 IO 硬件响应的。再展开就是 IO 模型的话题了，本文不过多讨论，不过也可以看出 IO 模型与并发编程的关系密不可分。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><div class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"><div></div><div class="mt-4 md:mt-0 md:text-right"><span class="text-primary-text block font-bold">下一页</span>
<a href=https://blog.zonowry.com/posts/install-hyprland-on-arch-and-simple-beautify/ class=block>Arch + Hyprland 安装手册</a></div></div></div><div class=col-span-2><div class="bg-primary-bg
prose sticky top-16 z-10 hidden px-6 py-4 lg:block"><h3>本页内容</h3></div><div class="sticky-toc hidden px-6 pb-6 lg:block"><nav id=TableOfContents><ul><li><a href=#引言>引言</a></li><li><a href=#理论指导实践>理论指导实践</a><ul><li><a href=#抢占式调度>抢占式调度</a></li><li><a href=#协作式调度>协作式调度</a></li></ul></li><li><a href=#实践中的问题>实践中的问题</a><ul><li><a href=#缓存一致性>缓存一致性</a></li><li><a href=#读写有序性>读写有序性</a></li><li><a href=#原子一致性>原子一致性</a></li></ul></li><li><a href=#高速的安全并发>高速的安全并发</a><ul><li><a href=#串行编程>串行编程</a><ul><li><a href=#原子指令><strong>原子指令</strong></a></li><li><a href=#信号量><strong>信号量</strong></a></li></ul></li><li><a href=#不可变变量>不可变变量</a></li><li><a href=#分布式事务>分布式事务</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div><script>window.addEventListener("DOMContentLoaded",()=>{enableStickyToc()})</script></div><div class="bg-secondary-bg prose col-span-2 rounded p-6 lg:col-span-6"><h3>相关</h3><a href=https://blog.zonowry.com/posts/install-hyprland-on-arch-and-simple-beautify/ class=no-underline>Arch + Hyprland 安装手册</a><br><a href=https://blog.zonowry.com/posts/how-to-write-code-that-is-easy-to-maintain/ class=no-underline>如何写一手容易维护的代码</a><br><a href=https://blog.zonowry.com/posts/build-a-proxy-gateway-based-on-iptables-and-clash/ class=no-underline>iptables + clash 透明网关实践与总结</a><br></div></div><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script></div></div></main><footer class=pl-scrollbar><div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b"><p class="text-sm text-tertiary-text">zonowry &#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p></div></div></footer></body></html>