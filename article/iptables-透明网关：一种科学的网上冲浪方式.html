<!doctype html><html><head><title>Iptables 透明网关：一种科学的网上冲浪方式</title><base href="../"><meta id="root-path" root-path="../"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=yes,minimum-scale=1,maximum-scale=5"><meta charset="UTF-8"><link rel="icon" href="lib/media/favicon.png"><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="stylesheet" href="lib/styles/supported-plugins.css"><link rel="stylesheet" href="lib/styles/theme.css"><link rel="stylesheet" href="lib/styles/other-plugins.css"><link rel="stylesheet" href="lib/styles/snippets.css"><link rel="stylesheet" href="lib/styles/global-variable-styles.css"><link rel="stylesheet" href="lib/styles/main-styles.css"><script src="lib/scripts/pixi.js"></script><script src="lib/scripts/webpage.js"></script><include src="lib/html/custom-head-content.html"></include></head><body class="loading theme-dark"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-container"><div class="sidebar-sizer"><div class="sidebar-content-positioner"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="search-input-container global-search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div></div></div></div><div class="sidebar-gutter"><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div></div><div class="document-container show"><div class="markdown-preview-view markdown-rendered allow-fold-headings"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><div class="markdown-preview-pusher" style="height:.1px;margin-bottom:0;width:1px"></div><div class="mod-header"><h1 id="inline-title"><p>Iptables 透明网关：一种科学的网上冲浪方式</p></h1></div><div><div data-callout-metadata="" data-callout-fold="" data-callout="tip" class="callout"><div class="callout-title"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-flame"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path></svg></div><div class="callout-title-inner">Tip</div></div><div class="callout-content"><p>本文非 clash 网关搭建教程，而是借代理网关的例子来学习了解 linux 网络的一些知识。不过也许能给正在搭建透明网关的你一些启发。</p><p>本文提到的旁路由、网关，若无特别说明指代的是同一台机器。</p></div></div></div><div class="heading-wrapper"><h2 data-heading="前言" class="heading" id="前言"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>前言<div class="heading-after">...</div></h2><div class="heading-children"><div><p>尝试用 <code>clash tun</code> 模式来实现过网关，虽然过程很流畅也比较“新潮“，但对于我来说有点魔法了，因为比较难搞清楚 <code>clash</code> 帮我们做了哪些工作，出现问题不好找原因。也可能是我比较“洁癖” ，所以我采用了 <code>iptables + tproxy</code> 这种更加“简单“的方式，<code>clash</code> 只作为流量中继，流量包的路由都依靠 linux 内核的 <code>netfilter</code> 模块实现，这样搭建的网关会更加“可控”一点。</p></div><div><p>然后我看了不少 <code>clash + linux netfilter(iptables/nftables) 搭建“富强”网关</code> 的教程文章。步骤都是很简单的，照着做就能实现。但每个人总会有点特殊需求，不去理解这些步骤的奥秘，很难解决一些特殊问题。</p></div><div><p>我就是遇到了公网上无法访问我网关上的 <code>docker</code> 服务，debug 排查了好久，虽然最后凭感觉解决了。但一直没有理顺流量是怎么路由的，只是稍有眉目、模棱两可。所以我去尝试理解了过程中每个操作（命令）的底层逻辑，现在写篇文章梳理一下这些知识。</p></div></div></div><div class="heading-wrapper"><h2 data-heading="linux 网络之 netfilter" class="heading" id="linux_网络之_netfilter"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>linux 网络之 netfilter<div class="heading-after">...</div></h2><div class="heading-children"><div><p>首先说说这一切的基石：linux 的 <code>netfilter</code> 模块及延伸工具 <code>iptables</code>。</p></div><div><p><code>iptables</code> 只是个命令行工具，依赖 <code>netfilter</code> 内核模块，也即真正实现防火墙功能的是 linux 内核的 <code>netfilter</code> 模块。可惜不仅 <code>iptables</code> 的命令宛若天书，<code>netfilter</code> 的链路也错综复杂，很难去使用。想要理解使用这些工具或命令，必须得先了解一些 <code>netfilter</code> 与 <code>iptables</code> 的基础知识。</p></div><div class="heading-wrapper"><h3 data-heading="iptables 的链" class="heading" id="iptables_的链"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>iptables 的链<div class="heading-after">...</div></h3><div class="heading-children"><div><p><code>netfilter</code> 提供了 <strong>5 个 hook</strong> 点，<code>iptables</code> 根据这些 <strong>hook</strong> 点，搞出了 <code>链 (chain)</code> 的概念，也就<strong>内置</strong>了 <strong>5 个默认链</strong>。可以看出 5 个 <code>iptables chian</code> 和 5 个 <code>netfilter hook</code> 一一对应。当然，我们可以添加自定义链，不过想要某个自定义链生效，需要追加一条从<strong>内置链</strong>跳转到这个自定义链的规则。因为内核的 5 个 hook 点只会触发这 5 个内置链。</p></div><div style="overflow-x:auto"><table><thead><tr><th>netfilter hook</th><th>iptables chain</th><th>netfilter hook 解释</th></tr></thead><tbody><tr><td>NF_IP_PRE_ROUTING</td><td>PREROUTING</td><td>接收到的包进入协议栈后立即触发此 hook，在进行任何路由判断 （将包发往哪里）之前</td></tr><tr><td>NF_IP_LOCAL_IN</td><td>INPUT</td><td>接收到的包经过路由判断，如果目的是本机，将触发此 hook</td></tr><tr><td>NF_IP_FORWARD</td><td>FORWARD</td><td>接收到的包经过路由判断，如果目的是其他机器，将触发此 hook</td></tr><tr><td>NF_IP_LOCAL_OUT</td><td>OUTPUT</td><td>&nbsp;本机产生的准备发送的包，在进入协议栈后立即触发此 hook</td></tr><tr><td>NF_IP_POST_ROUTING</td><td>POSTROUTING</td><td>本机产生的准备发送的包或者转发的包，在经过路由判断之后， 将触发此 hook</td></tr></tbody></table></div></div></div><div class="heading-wrapper"><h3 data-heading="iptables 的表与动作" class="heading" id="iptables_的表与动作"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>iptables 的表与动作<div class="heading-after">...</div></h3><div class="heading-children"><div><p><code>iptables</code> 为了更颗粒度的管理流量，又设计出 <code>table</code> 的概念。用 <code>table</code> 来组织这些链，可以理解为每个 <code>table</code> 根据其用处包含了不同的链。每个 <code>table</code> 都支持一些“<strong>动作</strong>“。例如 <code>nat</code> 表的 <code>DNAT</code> 动作支持重写目标地址。不过有些动作只在特定的 <code>chain</code>（或者说 <code>hook</code>）上才有意义。例如向 <code>INPUT</code> 链添加 <code>DNAT</code> 动作时，内核会抛出这个错误：<code>ip_tables: DNAT target: used from hooks INPUT, but only usable from PREROUTING/OUTPUT</code>。另一个例子是 <code>mangle</code> 表不允许添加 <code>SNAT</code> 等动作，所以一个<strong>动作</strong>需要 <code>table</code> + <code>chain</code> 都允许才能被添加。</p></div><div style="overflow-x:auto"><table><thead><tr><th>表</th><th align="left">支持的内置链</th><th align="left">支持的动作（部分，仅供参考）</th></tr></thead><tbody><tr><td>mangle</td><td align="left">支持全部 5 个内置链</td><td align="left"><code>RETURN</code> <code>TPROXY</code></td></tr><tr><td>raw</td><td align="left"><code>PREROUTING</code> <code>OUTPUT</code></td><td align="left"><code>TRACE</code></td></tr><tr><td>nat</td><td align="left"><code>PREROUTING</code> <code>INPUT</code> <code>OUTPUT</code> <code>POSTROUTING</code></td><td align="left"><code>SNAT</code> <code>DNAT</code> <code>REDIRECT</code> <code>MASQURADE</code></td></tr><tr><td>filter</td><td align="left"><code>INPUT</code> <code>FORWARD</code> <code>OUTPUT</code></td><td align="left">略</td></tr><tr><td>security</td><td align="left">略</td><td align="left">略</td></tr></tbody></table></div><div><p>每个 <code>table</code> 的 <code>chain</code> 当然也是有触发顺序的，具体顺序可以参考那张著名的 <code>netfilter 流程图</code> ，或<a data-tooltip-position="top" aria-label="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" rel="noopener" class="external-link" href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank">这篇文章</a>的介绍 。</p></div><div><div style="background:#fff"><img title="netfilter 流程图" src="https://arthurchiao.art/assets/img/deep-dive-into-iptables-netfilter/Netfilter-packet-flow.svg" referrerpolicy="no-referrer"></div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="流量方向 与 iptables 规则" class="heading" id="流量方向_与_iptables_规则"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>流量方向 与 iptables 规则<div class="heading-after">...</div></h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="开启内核转发功能" class="heading" id="开启内核转发功能"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>开启内核转发功能<div class="heading-after">...</div></h3><div class="heading-children"><div><p>要想把一台 linux 机器配置成有路由转发功能的机器，第一步需要用以下命令开启内核转发功能。</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">sysctl -w net.ipv4.ip_forward<span class="token operator">=</span><span class="token number">1</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p>单单这条命令只是将 linux 机器做成中继路由，一般情况下没太大意义。我们还需要处理途径机器的流量。即设定规则将途径流量“路由（转发）”到本机某些程序上（常用如 <code>clash</code> 或者 <code>v2ray</code> ），经代理中转后再原路返回。达成“加速网络”的目的。 <code>iptables</code> 等相关工具就登场了。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="局域网流量跳过处理，直连主路由" class="heading" id="局域网流量跳过处理，直连主路由"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>局域网流量跳过处理，直连主路由<div class="heading-after">...</div></h3><div class="heading-children"><div><p>linux 系统是可以作为<strong>主路由</strong>的，但一般的机器没有多个网口，所以都是作为<strong>旁路由</strong>来辅助主路由。既然作为旁路由来使用，我们只想代理加速公网流量，局域网内机器的流量肯定还是希望通过<strong>主路由</strong>来直连，没必要再来来回回途径一次旁路由了。所以需要添加一些<strong>转发规则</strong>，让旁路由跳过局域网内流量，原封不动转出去，让主路由继续去路由。</p></div><div><p>结合 netfilter 段落的知识，逆向思考一下要怎么做。首先我们要添加一些<strong>路由规则</strong>，这些规则最终肯定是注入到 netfilter hook 里的，可以通过 <strong>iptables chain</strong> 操作 netfikter hook。所以规则要添加到一个<strong>合适</strong>的 <strong>chain</strong> 里，<strong>iptables</strong> 又是通过 <strong>table</strong> 来组织管理 <strong>chain</strong> 的。我们还需要找一个<strong>合适</strong>的 <strong>table</strong> 来添加 <strong>chain</strong>（或者说规则）。思考了这些后，我们再回头看命令：</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded"><span class="token comment"># clash 链负责处理转发流量</span>
iptables -t mangle -N clash

<span class="token comment"># 让所有流量通过 clash 链进行处理</span>
iptables -t mangle -A PREROUTING -j clash

<span class="token comment"># 目标地址为局域网或保留地址的流量跳过处理</span>
iptables -t mangle -A clash -d <span class="token number">0.0</span>.0.0/8 -j RETURN
iptables -t mangle -A clash -d <span class="token number">127.0</span>.0.0/8 -j RETURN
iptables -t mangle -A clash -d <span class="token number">10.0</span>.0.0/8 -j RETURN
iptables -t mangle -A clash -d <span class="token number">172.16</span>.0.0/12 -j RETURN
iptables -t mangle -A clash -d <span class="token number">192.168</span>.0.0/16 -j RETURN
iptables -t mangle -A clash -d <span class="token number">169.254</span>.0.0/16 -j RETURN
iptables -t mangle -A clash -d <span class="token number">224.0</span>.0.0/4 -j RETURN
iptables -t mangle -A clash -d <span class="token number">240.0</span>.0.0/4 -j RETURN
</code><button class="copy-code-button">Copy</button></pre></div><div><ul><li data-line="0">首先我们新建了一个自定义链管理规则：<code>iptables -t mangle -N clash</code></li><li data-line="1">然后从内置链 <code>PREROUTING</code> 跳转而来：<code>iptables -t mangle -A PREROUTING -j clash</code><ul><li data-line="2">当然我们可以直接不写这两句，直接将规则添加到 <code>PREROUTING</code> 链。但那样写不是很规范，不推荐直接向内置链（这里是 <code>PREROUTING</code> ）添加规则。</li></ul></li><li data-line="3">然后追加局域网IP直连规则到 <code>clash</code> 表中 我们使用的表是 mangle 表，链是 链。 总而言之，最终实现了局域网机器流量发到<strong>旁路由</strong>时，旁路由发现目标地址是局域网内ip，跳过处理，转发出去给到主路由，就是主路由和源主机直接通信了，之后的网络传输本网关就不会参与了。</li></ul></div></div></div><div class="heading-wrapper"><h3 data-heading="中转外网流量，clash 透明代理" class="heading" id="中转外网流量，clash_透明代理"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>中转外网流量，clash 透明代理<div class="heading-after">...</div></h3><div class="heading-children"><div><p>由于上一步我们跳过了内部（局域网内）流量，剩下的流量基本就是外部（互联网）流量了。这些<strong>外部流量</strong>应该要转发到 <code>clash</code> 中进行透明代理。</p></div><div><p>虽然可以简单的通过 <code>REDIRECT</code> 动作将流量转发到 <code>7893</code> 端口。但 <code>REDIRECT</code> 不能很好的支持 <code>UDP</code> 流量。所以采用 <code>TPROXY</code> 方式，这样 <code>TCP</code> 和 <code>UDP</code> 都能支持。</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded"><span class="token comment"># tproxy 7893（clash） 端口，并打上 mark 666 命中策略，走 666 路由表</span>
iptables -t mangle -A clash -p tcp -j TPROXY --on-port <span class="token number">7893</span> --tproxy-mark <span class="token number">666</span>
iptables -t mangle -A clash -p udp -j TPROXY --on-port <span class="token number">7893</span> --tproxy-mark <span class="token number">666</span>

<span class="token comment"># 转发所有 DNS 查询到 1053 端口</span>
<span class="token comment"># 此操作会导致所有 DNS 请求全部返回虚假 IP(fake ip 198.18.0.1/16)</span>
iptables -t nat -I PREROUTING -p udp --dport <span class="token number">53</span> -j REDIRECT --to <span class="token number">1053</span>

<span class="token comment"># 添加策略与路由表（）</span>
<span class="token function">ip</span> rule <span class="token function">add</span> fwmark <span class="token number">666</span> lookup <span class="token number">666</span>
<span class="token function">ip</span> route <span class="token function">add</span> <span class="token builtin class-name">local</span> <span class="token number">0.0</span>.0.0/0 dev lo table <span class="token number">666</span>
</code><button class="copy-code-button">Copy</button></pre></div><div><p>前两句 <code>iptables</code> 命令，追加了两条 <code>TPROXY</code> 规则。将 <code>tcp</code> &amp; <code>udp</code> 流量转发到 <code>clash</code> 的 <code>7893</code> 端口，且打了 <code>666</code> 标记。</p></div><div><p>因为 <code>TPROXY</code> 不会修改 IP 数据包，数据包的 dest ip 一般都是外网地址，所以数据包下一跳会直接 forward 转出到下一跳机器上。因此 <code>TPROXY</code> 大部分情况都需要搭配 <code>ip route</code> 策略路由一起使用。比如我们这里就是新建了一个名为 <code>666</code> 的路由表，此路由表会将所有数据包发到本地回环上。这样就阻断了 forward 过程，相当于让（ <code>tproxy</code> 过的）数据包重新走一边网络栈流程。这样数据包就可以转发到 <code>7893</code> 端口上了，然后我们只让有 <code>666</code> 标记的数据包经过此路由表。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="代理网关本机的流量" class="heading" id="代理网关本机的流量"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>代理网关本机的流量<div class="heading-after">...</div></h3><div class="heading-children"><div><p>经过以上步骤，局域网内的其它机器已可以正常使用本网关了。当然，一台 llinux 机器只用来当一个网关太浪费了，还可以跑各种服务以及日常使用。顺便将本机的流量也代理一下，也即代理本机发出（经过 <code>OUTPUT</code> 链）的数据包。</p></div><div><p>首先与上一步类似的步骤，将本机发出的流量（OUTPUT）打上标记，触发重新路由。这样本机发出的流量就和局域网内其它机器进入的流量相同了，路由的流程也就一样了。不过 <code>OUTPUT</code> 上的数据包也会包含 clash 发出流量，这样会出现数据包死循环，得处理一下。只需要跳过 clash 程序发出的数据包，避免死循环。用 clash 用户启动 clash 程序，根据 uid 跳过数据包即可。。</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded"><span class="token comment"># clash_local 链负责处理网关本身发出的流量</span>
iptables -t mangle -N clash_local

<span class="token comment"># nerdctl 容器流量重新路由</span>
<span class="token comment">#iptables -t mangle -A clash_local -i nerdctl2 -p udp -j MARK --set-mark 666</span>
<span class="token comment">#iptables -t mangle -A clash_local -i nerdctl2 -p tcp -j MARK --set-mark 666</span>

<span class="token comment"># 跳过内网流量</span>
iptables -t mangle -A clash_local -d <span class="token number">0.0</span>.0.0/8 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">127.0</span>.0.0/8 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">10.0</span>.0.0/8 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">172.16</span>.0.0/12 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">192.168</span>.0.0/16 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">169.254</span>.0.0/16 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">224.0</span>.0.0/4 -j RETURN
iptables -t mangle -A clash_local -d <span class="token number">240.0</span>.0.0/4 -j RETURN

<span class="token comment"># 为本机发出的流量打 mark</span>
iptables -t mangle -A clash_local -p tcp -j MARK --set-mark <span class="token number">666</span>
iptables -t mangle -A clash_local -p udp -j MARdocK --set-mark <span class="token number">666</span>

<span class="token comment"># 跳过 clash 程序本身发出的流量, 防止死循环(clash 程序需要使用 "clash" 用户启动) </span>
iptables -t mangle -A OUTPUT -p tcp -m owner --uid-owner clash -j RETURN
iptables -t mangle -A OUTPUT -p udp -m owner --uid-owner clash -j RETURN

<span class="token comment"># 让本机发出的流量跳转到 clash_local</span>
<span class="token comment"># clash_local 链会为本机流量打 mark, 打过 mark 的流量会重新回到 PREROUTING 上</span>
iptables -t mangle -A OUTPUT -j clash_local
</code><button class="copy-code-button">Copy</button></pre></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="外网访问内网 docker 问题" class="heading" id="外网访问内网_docker_问题"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>外网访问内网 docker 问题<div class="heading-after">...</div></h2><div class="heading-children"><div><p>也可以说外网访问局域网内机器（非网关机器）的问题。我们这样配置好后，会发现无法从外网访问内网的 docker 服务（设置路由器端口转发）。可以通过手机流量访问测试。</p></div><div><p>我是参考该 <a data-tooltip-position="top" aria-label="https://github.com/Dreamacro/clash/issues/432#issuecomment-571634905" rel="noopener" class="external-link" href="https://github.com/Dreamacro/clash/issues/432#issuecomment-571634905" target="_blank">github issue</a> 受到了启发，最终解决了。</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded"><span class="token comment"># 跳过 docker0 的 ip 范围。即跳过 docker 服务的出站数据包</span>
<span class="token function">sudo</span> iptables -t mangle -A clash -p tcp -s <span class="token number">172.18</span>.0.0/16 -j RETURN
</code><button class="copy-code-button">Copy</button></pre></div><div><p>然后以下是个人的推测，可能有误，仅供参考。</p></div><div><p>首先手机入站数据包经过路由器，<code>NAT</code> 到 <code>docker</code> 服务（网关机器）上。此时因为 <strong>dest ip</strong> 是内网 ip，<strong>clash 链</strong> 会跳过。<strong>DOCKER 链</strong> 接手处理，通过 <code>DNAT</code> 转发到了 <strong>docker0 bridge</strong> 网卡上，这几步都很正常。顺利到达 docker 容器。</p></div><div><p>随后是 docker 容器的出站数据包，此时数据包会从 <strong>docker0 bridge</strong> 发到宿主机的物理网卡 <strong>eth</strong> 网卡。这时数据包之于宿主机来说，是一个入站数据包。数据包会经过 <code>PREROUTING</code> 链，jump 到 <strong>clash</strong> 链，而此时的 <strong>dest ip</strong> 为手机的 ip 。会被转发到 clash 上处理，但这个数据包只在出站时转发给 clash 处理。入站的时候跳过了。估计 clash 无法处理这个数据包，可能就丢弃了。就出现了外网无法访问内网 docker 容器的问题。</p></div><div><p>所以根据 source ip 判断， 将 docker 容器的数据包也跳过。跳过后就解决了～</p></div></div></div><div class="heading-wrapper"><h2 data-heading="参考" class="heading" id="参考"><div class="heading-before"></div><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>参考<div class="heading-after">...</div></h2><div class="heading-children"><div><ul><li data-line="0"><a data-tooltip-position="top" aria-label="https://moecm.com/something-about-v2ray-with-tproxy/" rel="noopener" class="external-link" href="https://moecm.com/something-about-v2ray-with-tproxy/" target="_blank">第一篇万字长文：围绕透明代理的又一次探究</a></li><li data-line="1"><a data-tooltip-position="top" aria-label="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" rel="noopener" class="external-link" href="https://arthurchiao.art/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank">「译」深入理解 iptables 和 netfilter 架构</a></li><li data-line="2"><a data-tooltip-position="top" aria-label="https://mritd.com/2022/02/06/clash-tproxy/" rel="noopener" class="external-link" href="https://mritd.com/2022/02/06/clash-tproxy/" target="_blank">树莓派 Clash 透明代理(TProxy)_</a></li><li data-line="3"><a data-tooltip-position="top" aria-label="https://github.com/mritd/tpclash/wiki/2%E3%80%81%E8%BF%9B%E9%98%B6%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" rel="noopener" class="external-link" href="https://github.com/mritd/tpclash/wiki/2%E3%80%81%E8%BF%9B%E9%98%B6%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6" target="_blank">tpclash wiki - 2、进阶流量控制</a> 。</li><li data-line="4"><a data-tooltip-position="top" aria-label="https://tinychen.com/20200414-iptables-principle-introduction/" rel="noopener" class="external-link" href="https://tinychen.com/20200414-iptables-principle-introduction/" target="_blank">iptables的四表五链与NAT工作原理&nbsp;_</a></li><li data-line="5"><a rel="noopener" class="external-link" href="https://www.zhaohuabing.com/learning-linux/docs/tproxy/" target="_blank">https://www.zhaohuabing.com/learning-linux/docs/tproxy/</a></li></ul></div><div class="mod-footer"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-gutter"><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-container"><div class="sidebar-sizer"><div class="sidebar-content-positioner"><div class="sidebar-content"><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display:none"></div><div class="tree-item" data-depth="1"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#Iptables_透明网关：一种科学的网上冲浪方式" heading-name="Iptables_透明网关：一种科学的网上冲浪方式"><span class="tree-item-title">Iptables 透明网关：一种科学的网上冲浪方式</span></a></div><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#前言" heading-name="前言"><span class="tree-item-title">前言</span></a></div><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#linux_网络之_netfilter" heading-name="linux_网络之_netfilter"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">linux 网络之 netfilter</span></a></div><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#iptables_的链" heading-name="iptables_的链"><span class="tree-item-title">iptables 的链</span></a></div><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#iptables_的表与动作" heading-name="iptables_的表与动作"><span class="tree-item-title">iptables 的表与动作</span></a></div><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#流量方向_与_iptables_规则" heading-name="流量方向_与_iptables_规则"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">流量方向 与 iptables 规则</span></a></div><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#开启内核转发功能" heading-name="开启内核转发功能"><span class="tree-item-title">开启内核转发功能</span></a></div><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#局域网流量跳过处理，直连主路由" heading-name="局域网流量跳过处理，直连主路由"><span class="tree-item-title">局域网流量跳过处理，直连主路由</span></a></div><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#中转外网流量，clash_透明代理" heading-name="中转外网流量，clash_透明代理"><span class="tree-item-title">中转外网流量，clash 透明代理</span></a></div><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#代理网关本机的流量" heading-name="代理网关本机的流量"><span class="tree-item-title">代理网关本机的流量</span></a></div><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#外网访问内网_docker_问题" heading-name="外网访问内网_docker_问题"><span class="tree-item-title">外网访问内网 docker 问题</span></a></div><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><div class="tree-item-contents"><a class="webpage-link tree-item-link heading-link" href="article\iptables-透明网关：一种科学的网上冲浪方式.html#参考" heading-name="参考"><span class="tree-item-title">参考</span></a></div><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div></div></div></div></body></html>