<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kasyoumi的博客</title>
    <link>/</link>
    <description>Recent content on Kasyoumi的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 24 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>垃圾回收知识梳理</title>
      <link>/posts/gc-note/</link>
      <pubDate>Sat, 24 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/gc-note/</guid>
      <description>堆内存与栈内存 垃圾一般就是指没用了的对象。对象的值一般存储在堆空间中。而基础类型、对象的引用以及大小确定的一些结构类型存储在栈空间中，函数执行就是靠不停的进出方法栈，每执行一步，就会退出一个栈，清理掉这些栈空间数据，切换到下一个栈。
也即对象的引用被销毁掉了，那么堆空间对象的值就变成无用数据了。所以通常我们讲垃圾回收都是在针对堆空间中的对象值。
在c/c++中，对象提供了析构函数让我们手动释放资源。而在java等托管语言中，有虚拟机提供了垃圾回收机制，帮我们处理这些在堆内存中没用了的对象（垃圾）。
如何识别标记垃圾 那接下来的重点就是虚拟机如何讲对象识别为垃圾，这样虚拟机才能回收垃圾。一般有两种方法，引用计数和根搜索算法。
引用计数算法 顾名思义，一个对象被创建后，我们计数这个对象被引用的次数。如果引用次数为0，则说明这个对象不再被使用了。
同时也引出了一个巨大的问题，当出现两个对象互相引用时，引用计数永远不会到达0。那么就造成了内存泄漏。所以引用计数算法现在已经退隐江湖了，只在很早期的虚拟机中出现过。
根搜索算法 根搜索算法也很容易理解。我们从一个“根对象”开始出发，想象出一个图状结构，形成一条条连接的引用链。不在这些引用链中的对象，就是垃圾对象。
核心思想就是找到不可达的对象，这些不可达的对象自然就是垃圾对象了。
如何回收垃圾 回收步骤 垃圾回收有很多算法，本文仅简单概述常见的，算法具体逻辑及实现可以百度看看其它文章。
首先是回收标记的垃圾对象。当我们回收完毕后，内存空间可能会出现不连续，造成空间浪费。垃圾回收器就需要对内存碎片进行整理。所以垃圾回收就是再做：标记-回收-整理，三个步骤。
回收算法 总结出规律，聪明的程序员就发明了高性能的整理回收算法。称之为 复制算法 Scavenge 。具体逻辑就是将内存空间对半分，回收时，将存活的对象复制到另一半空间中。最终一半空间是非活动对象，一半空间全是存活对象。垃圾回收器可以轻松的将一半空间清除，使之变为空闲区域。
垃圾分代 只用一种算法提升还不够大，程序员们就又针对空间使用规律。提出了对象分代的理念。区分长命的对象和短命的对象。常见的一种区分方式是：经过几轮垃圾回收还存活的，就是长命对象。反之则为短命对象。分别称之为新生代，老年代。
然后针对不同类别的对象实行不同的回收算法，有了针对性，也就节省了很多性能和空间开销。
扩展知识 除了这些通用的垃圾回收机制外。不同的编程语言虚拟机还提供了不同的特性。例如 java 虚拟机就提供了”强引用、软引用、弱引用和虚引用&amp;quot;特性。增强我们对对象的生命周期控制，影响垃圾回收器的工作。
可以看其它大佬的文章了解这些知识：理解Java的强引用、软引用、弱引用和虚引用
所以具体垃圾回收器，还是需要具体学习。不过知道这些知识也够用了～</description>
    </item>
    
    <item>
      <title>浅谈三种主流前端框架的数据追踪渲染</title>
      <link>/posts/data-tracker-and-render-of-webfront/</link>
      <pubDate>Fri, 23 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/data-tracker-and-render-of-webfront/</guid>
      <description>本文主要分析vue、react、angular之间一些本质上的不同之处，更好地理解和学习前端框架。以及从框架中学习一些优良设计。
数据绑定与渲染 前端框架带来的第一个特点就是数据绑定，即页面上的操作会影响数据，数据的变动也会影响并更新页面。例如用户操作输入框让 count 变量改变。或者代码写一个定时器，定时累加 count ，页面实时刷新。在三种前端框架里都能很容易的实现。
注：react 是基于状态的，每次都是全新的数据，也就没有数据绑定类似的概念了，稍后讲。
有了数据绑定就牵扯页面怎么渲染数据了。那么我们就来思考三种前端框架通过数据渲染界面，采用的方式有什么不同。
Vue 首先是 vue ，vue 支持 v-model 指令来实现双向绑定。用户在界面做的操作会直接影响model的值。
&amp;lt;input v-model=&amp;quot;text&amp;quot; /&amp;gt; 本质上就是页面自动处理注册了 onChange 事件，事件触发就会更改 count 的值。
那么界面是什么时候渲染的呢，vue 通过 es5 的提供的 Object.defineProperty() 方法。hook了每个对象 get 与 set 方法。从而监控对数据的操作。例如每当count被赋值，就可以执行类似 rerender 的方法，来重新渲染界面。这就是 vue 说自己是反应式的原因之一吧。
Angular angular 则是通过变更检测，也称为脏检测的机制，实现数据渲染到界面。双向绑定语法上angular与vue类似。都是一条model指令。
&amp;lt;input [(ngModel)]=&amp;quot;text&amp;quot; /&amp;gt; 在angular中，变更检测执行也很简单。就是从上至下的比较对象值或引用地址是否发生了变化。如果变化了，那就更新视图界面。什么时候触发变更检测就是angular的vue不同的地方。vue是通过getter，setter。angular则是通过patch了很多方法，例如按钮等控件元素的各种鼠标事件，以及一些公有方法，例如settimeout等等。当然也可以在变更model值后，手动调用脏值检测，markAsDirty。手动触发变更检测。
React react则没有数据双向绑定这个概念了，组件内部通过 setState() 更新状态（数据）。我们也一般通过类似以下方式实现“双向绑定”类似的效果。
render() { return &amp;lt;input value={this.text} onChange={(event) =&amp;gt; { this.setState({text: event.target.value}) }) /&amp;gt; } 为了性能考虑，这种方式不利于局部更新。所以 react 利用了虚拟DOM树，通过diff算法比较新状态与旧状态。最终打补丁的方式更新真实dom树（界面）。
结尾 简单了解了下三种主流前端框架核心功能区别。它们分别是如何追踪变化、渲染数据的。从这上面出发可以帮助我们更好地学习，理解三种框架的不同之处。
然后vue和react是怎么利用虚拟dom树，进行diff算法的。不过这超出本文的范畴，就不再赘述了，网上有很多讲的很好的文章，例如：react和vue 虚拟dom的区别</description>
    </item>
    
    <item>
      <title>关于代码结构设计的一些思考</title>
      <link>/posts/project-thinking/</link>
      <pubDate>Thu, 22 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>/posts/project-thinking/</guid>
      <description>其实本文标题我想命名为《通过思考一些低端代码结构设计来领略高大上技术知识这件事》来着 生疏而难理解的工程 网上冲浪时经常能看到微服务、分布式等技术分享。但我们大多数开发面向的都是政企小群体用户，工作中很难实操这些技术。 也就在我们与高大上工程之间筑起了知识障壁。为了能理解高大上的技术，我们从简单的开始分析。
所以接下来我们不聊庞大的工程设计，来看看如何从我们日常的工作中学习这些模式的底层思想。 希望这篇文章能带来一点代码结构设计的启发，这层障壁或许会变薄一些。
从三层架构开始 最简单的架构，最单纯的思想。 为什么要分层 或者说为什么要分层，工作经验使我们能很快的说出是为了方便维护等。分层划分了代码职责，给编码一点约束，增加了点编码难度，但带来层次清晰的架构。我们来看看怎么通过分层得到一个容易维护的代码，或者说为什么分层可以让代码容易维护。
容易维护的代码 页面/表示层、业务逻辑层、数据访问层，三层简单到一句话就可以概括：“各层划分了一下责任，自上而下单向依赖”。按照此模式实现代码过于简单，我们不屑于实现（双手叉腰.jpg）。所以来聊点高大上的架构思路，对了解大型项目，写出容易维护的代码很有帮助。
可以想象如果不分层（划分代码），各种代码写在一个函数中，等到需求变更需要更新代码逻辑时。就像在听歌时需要先掏出牛仔裤裤兜中的有线耳机一样。
为什么会有这种感觉，因为各种职责的代码在一个函数中纵横交错。所以我们通常会根据职责划分代码（分层）。下面是一个简单的 http 后台接口代码，处理用户注册请求。
// 1. 接收浏览器发出的请求 @PostMapping(&amp;quot;/user/register&amp;quot;) fun registerUser( // 2. 提取请求体中的参数数据 @RequestParam name: String, @RequestParam userRole: UserRole ) { // 3. 业务逻辑：用户名不能重复 val isExists = database.query(&amp;quot;select * from user where name=?1&amp;quot;, name) != null if (isExists) { throw RuntimeException(&amp;quot;用户名已存在&amp;quot;) } // 4. 业务逻辑：不能创建管理员角色 if (isAdminRole(userRole)) { throw RuntimeException(&amp;quot;不允许注册为管理员用户&amp;quot;) } // 5. 业务逻辑：注册用户（创建用户对象） val newUser = User(name) user.password = encrypt(randomPwd()) user.registerTime = Instant.</description>
    </item>
    
  </channel>
</rss>
