---
title: Draft：我们仍未确定那刻所看见的变量的状态
date: 2023-02-15
tags: [java,并发]
categories: 知识
toc: true
mathjax: true
author: zonowry
description: "协程、反应式、异步、非阻塞、线程、进程、结构化并发、虚拟线程等等术语太多了。这些技术都可以让多个**任务**产生同时运行·中的效果，也就是并发执行，乍一看好像都是一回事嘛。为了彻底扫清迷雾，就来捋一捋并发编程相关知识，没有学术般的介绍，纯自己的心得总结，纯纯的私货，谨慎食用。"
---

> 从前有个程序员遇到了一个性能问题。他想，没事，我懂，用线程就好了。现他有在个两题了问。

## 前言

**协程、反应式、异步、非阻塞、线程、进程、结构化并发、虚拟线程**等等术语太多了。这些技术都可以让多个**任务**产生同时运行·中的效果，也就是多任务并发执行，乍一看好像都是一回事嘛。为了彻底扫清迷雾，就来捋一捋并发编程相关知识，没有学术般的介绍，纯自己的心得总结，纯纯的私货，谨慎食用。

> 并发、并行、异步、非阻塞等术语就不过多讲究了，讲究下去，可能半篇都要用来介绍术语名词


## 理论指导实践

接触 **Thread、协程、webflux、rxjava、js 事件队列**等具体技术框架的时候，也许看看 Api 文档就能懂一点原理、轻松上手，但有时候遇到复杂点的场景，问题就会在脑子里绕来绕去，捋不清执行过程。不过只要知道他们都是并发，然后抛开上层实现，从工作机理(?)层面上思考，我认为并发技术主要可以概括为以下两大类：**抢占式**和**协作式**。

### 抢占式调度

竞争控制权，A 任务与 B 任务互相抢占执行。通常指 cpu 时钟中断时多进程、多线程的工作模式，每次中断都代表一个线程抢到了时间片（控制权）。

在操作系统的抢占式的机制下，一个程序想要并发执行多任务，首先需要分割代码，这样不同的代码块得以快速交替执行，看起来像同时运行一样，就是并发了。那如何让代码块适配兼容操作系统的抢占式调度，**线程**就被设计出来了。我们编写代码时，如果想要某个代码块并发执行，一般只需要 `new Thread`，接着 **run it** 。之后的事情就是操作系统来调度了，也就是没法确定这个代码块（线程）什么时候会被执行（一般很快）。

### 协作式调度

也叫非抢占式，主动让渡控制权，A 任务与 B 任务可以在合适的时机主动让渡控制权。特点就是主动让出，也即不需要依靠操作系统中断，我们就可以让出控制权，A 任务主动暂停（中断）执行，把控制权让给 B 任务。这个特性我们可以在用户代码层面就可以很简单的实现，也就出现了反应式、非阻塞等相关概念的框架，例如 `rxjava`、`webflux`、`r2dbc` 等等，有的语言在编译器层面就支持了了一些并发语法糖，例如 `async`、`suspand` 之类的。

### 再加深一下，线程和协程

那线程是抢占式吗？由于「线程」加上「操作系统中断」就是一个天然的「抢占式框架」了，我们通常会把抢占式和线程绑定，这样理解没问题。

但也可以这样理解。我们可以基于线程搞个协作式调度，例如 A 线程只处理任务的第一个阶段，完成后发个事件。接着**等待一个合适的时机**，启动新线程处理该事件，继续执行任务的后续阶段。这样就像 A 线程主动让出了控制权一样，这种角度看线程就是协作式调度了。 有没有感觉有点像 `rxjava` 的 `publishOn`、`subscribeOn`。

那协程就一定是协作式的吗？大家一般把协程叫做「用户态线程」。理论上抢占式也可以在用户代码层实现，例如 `golang` 的协程就支持抢占式。

线程、协程和并发确实密不可分，但线程、协程都是一种执行单元，不是并发的核心思想。我认为并发核心的核心思想主要还是在它们的工作模式上：「主动开始（抢占），被动停止（中断）」和「主动停止（让渡），被动开始（接手）」。

## 内存模型

了解了并发的基本理论。线程的安全这种日经问题，肯定都了解点原因，是因为「并发环境下访问共享可变的状态」引起的。为什么这个操作会引起安全问题，好像理所当然想到数据会读写不一致。为什么会读写不一致？找出原因的话其实得看 cpu 如何访问共享数据的。

### 一致性（内存）

数据一致性问题，牵扯到内存模型，`java` 等托管语言搞得内存模型都是基于物理硬件的抽象，例如 `JMM (Java Memory Model)`，所以归根结底得看 **cpu 高速缓存**和**主内存**（内存条）的关系。

要知道 cpu 的计算速度可比内存条的读写速度高几个数量级，计算完一个数据就立马写入内存，会严重拖累 cpu 的计算速度。于是 cpu 中也有寄存器、高速缓存等存储区域，cpu 主要读写存储区域，速度比和主内存通信快多了，但数量上肯定比不过主内存。所以 cpu 执行一个代码块（单元）时，一般先从主内存读取数据拷贝到高速缓存里，之后就是 cpu 读写高速缓存了，然后适时的将高速缓存里的数据刷写到主内存中。由此看出从硬件层面上，为了提高性能，就无法避免的有类似缓冲、数据同步的概念。有数据同步就不可避免地有数据一致性问题了。

`java` 等高级语言为了避免我们太操心这些事情，设计实现了很多概念。例如运行时内存区域（堆栈、方法区...），然后 `JVM`、`CLR` 等都有高度封装的内存模型，负责线程间通信同步、线程隔离等等，大大简化编码的复杂程度。

### 原子性

暂时抛开引用类型、值类型、堆栈等知识，假设代码中不论何时获取变量，都是直接去物理内存中拿实时数据，类似于数据库事务级别的**读未提交**。这种情况下，所有的线程的数据读写是实时同步的，可以保证所有线程共享数据的一致性。这样能解决线程安全问题吗？不行，因为还有一个特性叫做原子性。

由此现了多个线程并发执行，它们共享某个数据时。那这个数据每时每刻的状态就不确定了。可能 A 线程刚把它设为 1 ，B 线程随后抢到控制权，把它更改成了 2 后，A 线程又抢到了控制权。这时候由于。

协作式的特性可以让我们像编写同步代码一样，基本不需要考虑这么一看好像抢占式没有优势，协作式全是优点。但抢占式确有个必不可少特性，因为它能确保任务总能执行。总会有一个老大哥样的角色，例如”操作系统“，平等的对待每一个线程，确保每个线程都能跑几毫秒。如果是协作式，当一个任务耗时很长，迟迟不让渡，其它的任务就干巴巴等它完成了。




## 调度器、迭代器


## IO 模型之非阻塞

## 

## 实现








## 参考

- [并发之痛 Thread，Goroutine，Actor](https://jolestar.com/parallel-programming-model-thread-goroutine-actor/)