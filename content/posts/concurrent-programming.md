---
title: Draft：我们仍未确定那刻所看见的变量的状态
date: 2023-02-15
tags: [java,并发]
categories: 知识
toc: true
mathjax: true
author: zonowry
description: "协程、反应式、异步、非阻塞、线程、进程、结构化并发、虚拟线程等等术语太多了。这些技术都可以让多个**任务**产生同时运行·中的效果，也就是并发执行，乍一看好像都是一回事嘛。为了彻底扫清迷雾，就来捋一捋并发编程相关知识，没有学术般的介绍，纯自己的心得总结，纯纯的私货，谨慎食用。"
---

> 从前有个程序员遇到了一个性能问题。他想，没事，我懂，用线程就好了。现他有在个两题了问。

## 前言

**协程、反应式、异步、非阻塞、线程、进程、结构化并发、虚拟线程**等等术语太多了。这些技术都可以让多个**任务**产生同时运行中的效果，也就是多任务并发执行，乍一看好像都是一回事嘛。为了彻底扫清迷雾，就来捋一捋并发编程相关知识，没有学术般的介绍，纯自己的心得总结，纯纯的私货，谨慎食用。

> 并发、并行、异步、非阻塞等术语就不过多讲究了，讲究下去，可能半篇都要用来介绍术语名词


## 理论指导实践

接触 **Thread、协程、webflux、rxjava、js 事件队列**等具体技术框架的时候，也许看看 Api 文档就能懂一点原理、轻松上手，但有时候遇到复杂点的场景，问题就会在脑子里绕来绕去，捋不清执行过程。不过只要知道他们都是并发，然后抛开上层实现，从工作机理(?)层面上思考，我认为并发技术主要可以概括为以下两大类：**抢占式**和**协作式**。

### 抢占式调度

竞争控制权，A 任务与 B 任务互相抢占执行。通常指 cpu 时钟中断时多进程、多线程的工作模式，每次中断都代表一个线程抢到了时间片（控制权）。

在操作系统的抢占式的机制下，一个程序想要并发执行多任务，首先需要分割代码，这样不同的代码块得以快速交替执行，看起来像同时运行一样，就是并发了。那如何让代码块适配兼容操作系统的抢占式调度，**线程**就被设计出来了。我们编写代码时，如果想要某个代码块并发执行，一般只需要 `new Thread`，接着 **run it** 。之后的事情就是操作系统来调度了，也就是没法确定这个代码块（线程）什么时候会被执行（一般很快）。

### 协作式调度

也叫非抢占式，主动让渡控制权，A 任务与 B 任务可以在合适的时机主动让渡控制权。特点就是主动让出，也即不需要依靠操作系统中断，我们就可以让出控制权，A 任务主动暂停（中断）执行，把控制权让给 B 任务。这个特性我们可以在用户代码层面就可以很简单的实现，也就出现了反应式、非阻塞等相关概念的框架，例如 `rxjava`、`webflux`、`r2dbc` 等等，有的语言在编译器层面就支持了了一些并发语法糖，例如 `async`、`suspand` 之类的。

### 再加深一下，线程和协程

线程、协程和并发确实密不可分，但线程、协程都是一种执行单元，我认为不是并发的核心思想，避开下误区，思考以下问题。

- 线程是抢占式吗？由于「线程」加上「操作系统中断」就是一个天然的「抢占式框架」了，我们通常会把抢占式和线程绑定，这样理解没问题。
但也可以这样理解。我们可以基于线程搞个协作式调度，例如 A 线程只处理任务的第一个阶段，完成后发个事件。接着**等待一个合适的时机**，启动新线程处理该事件，继续执行任务的后续阶段。这样就像 A 线程主动让出了控制权一样，这种角度看线程就是协作式调度了。 有没有感觉有点像 `rxjava` 的 `publishOn`、`subscribeOn`。

- 那协程就一定是协作式的吗？大家一般把协程叫做「用户态线程」。理论上抢占式也可以在用户代码层实现，例如 `golang` 的协程就支持抢占式。
协作式的特性可以让我们像编写同步代码一样，基本不需要考虑这么一看好像抢占式没有优势，协作式全是优点。但抢占式确有个必不可少特性，因为它能确保任务总能执行。总会有一个老大哥样的角色，例如”操作系统“，平等的对待每一个线程，确保每个线程都能跑几毫秒。如果是协作式，当一个任务耗时很长，迟迟不让渡，其它的任务就干巴巴等它完成了。

所以我认为要理解并发，核心主要还是在它们的工作模式上：「主动开始（抢占），被动停止（中断）」和「主动停止（让渡），被动开始（接手）」。

## 并发问题

了解了并发的基本理论。线程的安全这种日经问题，肯定都了解点原因，是因为「并发环境下访问共享可变的状态」引起的。为什么这个操作会引起安全问题，好像理所当然想到数据会读写不一致。为什么会读写不一致？要找出根本原因的话其实得看程序是如何访问共享数据的。

### 内存模型，一致性

数据一致性问题，或者说可见性，就牵扯到内存模型。`java` 等高级语言搞得内存模型都是基于物理硬件的抽象，例如 `JMM (Java Memory Model)`，所以归根结底得看 **cpu 高速缓存**和**主内存**（内存条）的关系。

要知道 cpu 的计算速度可比内存条的读写速度高几个数量级，计算完一个数据就立马写入内存，会严重拖累 cpu 的计算速度。于是 cpu 中也有寄存器、高速缓存等存储区域，cpu 主要读写存储区域，速度比和主内存通信快多了，但数量上肯定比不过主内存。所以 cpu 执行一个代码块（单元）时，一般先从主内存读取数据拷贝到高速缓存里，之后就是 cpu 读写高速缓存了，然后适时的将高速缓存里的数据刷写到主内存中。由此看出从硬件层面上，为了提高性能，就无法避免的有类似缓冲、数据同步的概念。有数据同步就不可避免地有数据一致性问题了。

`java` 等高级语言为了避免我们太操心这些事情，设计实现了很多概念。运行时内存区域（堆栈、方法区...）， 这些语言的编译器也都有高度封装的内存模型，负责线程间通信同步，保证线程数据同步、隔离等等。在用这些高级语言编程，cpu 高速缓存与主内存如何通信对我们来说是透明的，基本不需要去了解，大大简化编码的复杂程度。

### 算法操作，原子性

内存区域、内存模型只是为了更好地并发编程踏出的第一步。现在让我们暂时抛开引用类型、值类型、堆栈、内存模型等知识，假设代码中不论何时获取变量，都是直接去物理内存中拿实时数据，**不考虑性能**，类似于数据库的**读未提交**事务级别、`java` 的 `volatile` 关键字。这种情况下，所有的线程的数据读写是实时同步的，可以保证所有线程共享数据的一致性。这样能解决线程安全问题吗？不行，因为代码不只有数据，还有算法（指令与逻辑）。

这就和一个耳熟能详的特性——「**原子性**」有关了，看一个简单例子就能知道数据一致性不能完全解决线程安全问题的原因。

```kotlin
lateinit var flag: Boolean

// run in A Thread
fun aThread {
    flag = true 
    printLn("just do someting and then") 
    if(flag) {
	    printLn("when can i do ?")
	}
}

// run in B Thread
fun bThread {
	flag = false
}
```

假设 `aThread` 与 `bTread` 并发执行。先执行到了 `aThread` 的 `just do something and then`，这时触发中断，`bThread` 抢到控制权开始执行，将 `flag` 设为 `false`。导致 `aThread` 本该执行的 `when can i do` 跑不了。

可以看出 `flag` 数据是一致性了，但算法交替运行还是会发生问题。怎么解决例子中的问题？我们需要让 `aThread` 的执行不可被打断。即要么一次执行完 `aThread` 这个方法，要么就不要执行。这个特性就是原子性了，叫这个名字是因为不可打断的操作和原子不可分割的特性很像。


### 合适的“同步”

“说好的并发呢，怎么扯起同步来了👿️”。没办法，要想实现原子性，只能靠一些手段，这些手段会造成同步的效果，`java` 作者在他的书中写过： 

>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复该问题：
>- 不在线程之间共享该状态变量
>- 将该状态变量修改为不可变的变量
>- 再访问该状态变量时使用同步

第一种办法属于一刀切，很有效但适用度不高。第二种属于函数式编程思想，设计使用起来不比并发编程复杂。第三种就是不可分割的同步操作了。实现同步操作，离不开锁机制。




## 调度器、迭代器


## IO 模型之非阻塞

## 

## 实现








## 参考

- [并发之痛 Thread，Goroutine，Actor](https://jolestar.com/parallel-programming-model-thread-goroutine-actor/)