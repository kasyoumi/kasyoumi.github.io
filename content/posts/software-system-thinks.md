---
title: 如何写一手容易维护的代码
date: 2023-01-01
tags: [DDD]
categories: 文章
toc: true
descriptions: "可能是关于软件系统架构、工程设计、代码抽象的一些思考。"
---

# 免责声明

程序员对抽象、设计可能会有不同的习惯。同样一个功能有人用发布订阅，有人用消息队列，他们都有自己的一套设计理念。最终是谁能说服谁的问题，哪一种方式都不是绝对正确的，就像本文一样。
内容有点偏意识流，不过总结的都是些很简单的东西。文中提到的诸多“本质”，应该会再写一篇来举例说明吧。

# 人类智商受限

人类智商的难以理解庞大而复杂的软件系统，所以我们尝试用抽象来设计软件，设法以人类的智商也可以理解庞大的软件系统。

## 抽象是什么

管理自己的磁盘时，都会建立类似 Work、Software、Temp、Repo ...之类的文件夹。怎么分类文件夹最合理在这里不重要，重要的是分类文件夹前，肯定会进行的简单的**设计**。这个设计的思考过程我认为就是正在抽象。

举个不是很恰当的例子。我们不会为某一个 IDE 单独建立文件夹，来存放用它开发的代码文件。例如 `Intellij Projects`、`Visual Studio Projects` 。而是会尝试建立 `Projects`、`Repo`、`Workspace` 存放代码文件。这期间我们就是在抽象，把文件和具体的软件分离开，思考了这些文件的本质是”代码文件“，而非”某款软件的文件“。

抽象本质就是简化信息，是为了降低复杂度、是控制软件系统混乱程度的外在做功。

## 从三层架构开始思考

三层架构是一个很简单的，但抽象程度很高的模式。它可以解释大多数程序的组成：”有对外交互、有核心逻辑、有数据读写“。这就是它的高度抽象，把信息简化到了极致，所有程序都可以遵循三层架构模式写出来。三层本质是规范了代码边界，划分出三层边界：

- 用户交互层：接收“用户”的输入，向“用户”输出处理结果。
- 核心逻辑层：只负责程序的核心“算法”，如何处理数据。
- 数据交互层：妥协层，内存实现不了持久化，抽象出一个数据读写层代替内存。

代码设计的前期阶段，如何思考出一个模块的组成部分？三层架构给了我们一个优秀的示范。不需要思考功能的太多细节，**全力以赴的简化功能的细节，简单直接的阐述功能的本质**。

不过三层架构太抽象了，就像将“用户注册”抽象成“新增数据”，也就是相当于没有细节。如果只是从三层中学到了把代码按照交互、核心、读写划分的话，那实现细节还是会剪不断理还乱。只会套用三层架构范式，而不去思考功能本质的软件最终会难以维护，也许是屎山多是三层架构的原因（风评被害）。

## 最小人力成本

简单的东西却蕴藏大设计，架构大道反而在最简单的三层之中。只要适当的简化信息，边界划分的足够合适，架构最终会形成一个个聚合，开始有了领域驱动的味道。可难点就是边界如何划分的足够合适，信息如何简化才算符合抽象。

现实世界复杂的，软件系统的复杂度也是熵增的主旋律。我们的不变的设计总会有一天会遇到冲击。`handleUser`

不过结合实际工期限制，适当的抽象减轻维护难度就可以了。如果设计的非常全面，反而会给自己增加压力，延后工期。

## 当谈起代码抽象

要先认同抽象是一个很哲学的命题，百科对抽象的解释是找出事物的本质，剥离其它表象、杂质，最终形成一个“概念”。

然后务实的思考，抽象可以帮助我们简化代码，封装复用也好、继承多态也罢、接口定义先行。都是在“抽象”代码，以形成“某某功能”的概念，实现细节则是在具象（补完）这个概念。

使用第三方库时，遇到一些不清楚的方法，一般只需要在源码中找几个接口定义（注释）看看，或者阅读官网文档的 Api Reference 就能理解。这些库/框架都是“匠心之作”，它们的抽象单从版本更迭频率，就能看出来是很完美的，因为框架支持的功能很复杂。依靠抽象简化概念，修复 bug、新增功能时，我只需要确保我的“概念”还是不变的。这里“概念”就相当于一个依据，每次发版只需要确定这个依据不会发生改变。

接下来就是让代码变得“抽象”，

# 信息隐藏

==三层架构的简化很直接==，我们一直在提的“简化”，都能联想到就是“抽象”，诚然，简化是一种抽象，抽象是一种简化。例如，什么叫真正的封装 - “信息隐藏”。

```kotlin
// 3. 数据访问层
fun userDataAccess_GetUser(): User {
    return new User();
}

// 2.核心逻辑层
fun userBusiness_Login(): Boolean {
     val user = userDataAccess_GetUser()
     // 核心逻辑：只有周一允许登录
     return if(today() == '周一') true else false
}

// 1.用户交互层
fun userView_Login() {
    if(userBusiness_Login()) {
        return 'Redirect:/index.html'
    } else {
        // 错误的一种写法
        return "登录失败，只有周一才能登录"
        // 为什么上面的写法是错误的？
        // 因为核心逻辑层只返回了 false，没有说原因。
        // 用户界面层理应不知道原因，即使包含核心逻辑的 userBusiness_Login 方法也是你写的 
        return '登录失败，我不知道啥原因啊'
    }
}
```

例子中，代码的边界体现在「今天是周一才能登录系统」这个核心逻辑。用户界面层不应该知道这个细节。只根据核心逻辑层的返回值来做判断。即使核心逻辑层、用户交互层是同一个程序员写的代码，TA也应该克制（欺骗）自己，保持住代码的边界，即使返回给用户「只有周一才能登录」是更好用户体验。

简单来说就是，“我”忘记了核心逻辑层的代码，核心逻辑层只返回了一个 Boolean，指示登录是否成功。这样我的做法「登录失败，但我不知道原因」就很合理了。

## 抽象的代码：信息遮蔽

代码的边界似乎有一种大智若愚的感觉。有没有一种这不就是「接口类」 和 「实现类」嘛？就像“依赖接口而非依赖实现“一样。即使这段代码没有声明接口，我们是直接调用的方法（实现），但通过“欺骗”自己不知道实现细节，也有了类似调用接口的效果。或者反过来帮助我们理解接口的作用：隐藏实现细节。

可是明明知道实现细节，却又要隐藏实现细节。我们这么别扭的写代码是为了什么呢？抽象。

> 不是鹰酱的「不听话就夹你！夹你！夹！你！」那种抽象呀。是 Abstract ，是 Interface。

言归正传。大家一般接触到这样别扭的写法可能都是在写 `interface XxxxxService`，`class XxxxxServiceImpl : XxxxxService` 的时候。在改方法签名或新增方法的时候，都要改两个地方。感觉是很形式主义的，不明白为什么要这样做。有什么必要？这多数是因为开发角度、开发阶段不一样，如果只是看网上大家都这样做，那我也这样做。那必然会有这种“有必要吗”的想法。取决你你在写一个功能模块的时候，是先把所有接口声明完毕，敲定大体框架。还是先一个方法一个方法的渐进式实现。

当我们有这种想法时，说明我们对这个项目的潜力不报太大希望。如果我们对项目很看好，我们就会用心的考虑、设计：- 将来这些服务 `Service` 会不会开放给第三方？

当项目体量逐渐大起来，这样别扭的写法也。例如当我们思考以下问题时：

- 这个接口的实现是哪个同事写的？
    - 我不在意（除非要找个人背锅了）
    - 我不在意（除非要找个人背锅了）
- 这个接口的实现具体做了什么，怎么写的，用到了什么技术？
    - 关我什么事。我只关注它可以达成什么效果，我要给它什么参数，它返回了什么。
    - 关我什么事。我只关注它可以达成什么效果，我要给它什么参数，它返回了什么。
- 接口调用出错了，这可咋办？
    - 参数传的没问题，而且不是我写的？ 那就提 Issue 吧。
    - 是我写的，或者已经修复了？那抽空升级下实现（依赖）的版本吧。
    - 参数传的没问题，而且不是我写的？ 那就提 Issue 吧。
    - 是我写的，或者已经修复了？那抽空升级下实现（依赖）的版本吧。

当然上边的例子更多是一种对接口的戏谑。来点实际的例子，就像我们写 `java`，不用去理解 `public void main()` 背后发生了什么，只需要知道这是程序的主入口。这就是设计 `java` 语言的人，进行了抽象，我们用就完事了。减轻了我们程序员的脑力消耗，也就减轻了能量消耗，随之减轻了碳排放，功劳不浅啊。

## 抽象的边界：契约精神

边界和抽象，都聊过了。边界可以对“边界外”形成约定，抽象则可以让约定成为配置。

还可以在三层架构中发现一种代码边界，那就是用户交互层和客户端的「契约」或者说「约定」。


## 三位一体的抽象

信息隐藏、抽象、封装、内聚、耦合...等等关于代码设计的术语，这些术语不只属于面向对象范式。不要陷入思考这些术语意义的陷阱，想方设法让代码变的抽象。而是让只需要凭借“码感”，写出你认为更容易理解的代码。

抽象应该是你潜意识的活动，绝不应该是很难理解的东西。应该是你在有了一些经验后，不知不觉间写出的代码。


# 接着是贫血模型

到这里，对“代码边界”应该似懂非懂了一些吧。但 DDD 中的边界还要复杂一些，需要对业务建模，才能识别出代码边界，不过殊途同归。暂且将“边界”放到一边，随后我们将在 `DDD` 段落中继续探讨“边界”。

当我们潜意识中偏向写出这种代码，就说明你是写不出太离谱的屎山的。克制自己，欺骗自己。就像躺平了一样，我只知道这些，我也只能做到这些了。在现实生活中不算好的品质，在代码中就是恰到好处了，减轻了负担。
