---
tag:
- article
- blog
- concurrent
creation date: 2024-01-26 15:59
name: "an easy way to understand concurrent programming"
title: "轻松理解并发编程的一种思路"
lastmodify date: 2024-02-26 22:56
description: "我们仍未确定那天所见变量的状态"


description: 我们仍未确定那天所见变量的状态
date: 2024-01-26
lastmod: 2024-02-26 22:56
toc: true
isCJKLanguage: true
keywords:
  - zonowry
  - 轻松理解并发编程的一种思路
  - concurrent
  - threads
  - 并发
  - 反应式
  - 协程
  - coroutine
  - reactive
---

## 引言

说到并发，首先会想到多线程。可是只关注多线程如何使用，只会在代码里挖坑，变成这个段子的模样：“从前有个程序员遇到了一个性能问题。他想，没事，我懂，用线程就好了。现他有在个两题了问“。

为了避免这种情况，我们应该思考的是“为什么需要多线程，为什么 `js` 里没有多线程？”等诸类问题。将多线程看成是并发的一种手段，也就是让我们往下面 （the lower）走一点，越过线程理解并发编程。

> 如果逻辑控制流在时间上重叠，那么它们就是**并发的**（concurrent）—— 《CSAPP》

## 理论指导实践

首先忘掉习以为常的线程，因为线程不是很“抽象”，或许可以用`CSAPP` 书中的**逻辑控制流**代替，不过又过于极简了。下文我们就称之为「任务/执行单元」吧，代表一个可执行的“内容”。

再来分析 `thread（线程）`、`coroutine（协程）`、`reactive（反应式）`、`event/task queue（任务队列）`等各种并发**手段**。抛开上层的一些实现，本质上它们只是对**执行单元（洛基控制流）调度器**的不同实现。只需要搞清楚它们是如何调度**执行单元**的，那么就很好理解了。

### 定义执行单元

首先它的抽象定义肯定就是“逻辑控制流”，硬件电路形成的一组逻辑。应用级一点的解释是一个可以执行的内容，可以是线程、协程、观察者订阅、FutureTask/Event Callback......不在定义上过多浪费精力，当作一个抽象概念方便达成共识即可。

### 抢占式调度

首先是最常见的抢占式调度，操作系统的调度方式。

任务间呈现为**竞争**关系，A 任务与 B 任务互相抢占执行。最常见的例子就是：“操作系统利用 cpu 时钟中断时，实行的多线程的工作模式，每次中断都代表某个线程抢到了 CPU 时间片”。因为 CPU 中断是纳秒级别的，所以操作系统的抢占式调度可以提供一种所有线程在同时执行的假象。

抢占式调度下，执行单元无法确定自己什么时候会被执行，且任何时刻都可能会被中断执行。反过来说，如果我们基于此特性，处理好执行单元的竞争执行与随机中断，就实现了一个抢占式调度器。

### 协作式调度

主动让渡控制权，A 任务与 B 任务可以在**合适**的时机**主动**让渡出控制权。特点是持有控制权的任务主动中断，~~抛开现实不谈（例如 CPU 中断），~~这也突出了协作式调度的优点与理念——“调度不会影响**顺序性**“。因为我们是主动让出的，继续执行时可以找到让渡时的节点来保证顺序性，也可以理解为调度器会帮我们将执行单元恢复到让渡前一刻的状态，然后就像没让渡过一样继续执行。

协作式调度，执行单元知道自己什么时候会让出，同时也是**无感知**的，因为当再次拿到控制权时可以保持顺序性。这种特性大大提高了程序员们的并发编程体验。于是出现了很多协作式调度框架，不论是 `rx`，还是 `coroutine` ，它们本质上都是协作式调度，只是实现方式、思路不同。

有的语言在编译器层面就支持了了一些并发语法糖，例如 `async`、`suspand` 之类的。

### 线程与协程

线程、协程和并发确实密不可分，但线程、协程都是一种**执行单元**，我认为不是并发的核心思想，避开下误区，思考以下问题。

**线程是抢占式吗？**

由于「线程」加上「操作系统中断」就是一个天然的「抢占式框架」了，我们通常会把抢占式和线程绑定，这样理解没问题。

但也可以这样理解。我们可以基于线程搞个协作式调度，例如 A 线程只处理任务的第一个阶段，完成后发个事件。接着**等待一个合适的时机**，启动新线程处理该事件，继续执行任务的后续阶段。这样就像 A 线程主动让出了控制权一样，这种角度看线程就是协作式调度了。 有没有感觉有点像 `rxjava` 的 `publishOn`、`subscribeOn`。

**那协程一定是协作式的吗？**

大家一般把协程叫做「用户态线程」。理论上抢占式也可以在用户代码层实现，例如 `golang` 的协程就支持抢占式。

协作式的特性可以让我们像编写同步代码一样，基本不需要考虑这么一看好像抢占式没有优势，协作式全是优点。但抢占式确有个必不可少特性，因为它能确保任务总能执行。总会有一个老大哥样的角色，例如”操作系统“，平等的对待每一个线程，确保每个线程都能跑几毫秒。如果是协作式，当一个任务耗时很长，迟迟不让渡，其它的任务就干巴巴等它完成了。

所以我认为要理解并发，核心主要还是在它们的工作模式上：「主动开始（抢占），被动停止（中断）」和「主动停止（让渡），被动开始（接手）」。

## 实践中的问题

了解了并发的基本理论，再分析实践中的线程安全这种日经问题，原因只有「并发环境下访问共享可变的状态」。但为什么**共享状态**这个操作会引起问题？因为数据读写不一致。为什么会读写不一致？那就需要看一看多任务是如何读写状态的。

### 内存模型，一致性

数据一致性问题，或者说可见性，就牵扯到内存模型。`java` 等高级语言搞得内存模型都是基于物理硬件的抽象，例如 `JMM (Java Memory Model)`，所以归根结底得看 **cpu 高速缓存**和**主内存**（内存条）的关系。

要知道 cpu 的计算速度可比内存条的读写速度高几个数量级，计算完一个数据就立马写入内存，会严重拖累 cpu 的计算速度。于是 cpu 中也有寄存器、高速缓存等存储区域，cpu 主要读写存储区域，速度比和主内存通信快多了，但数量上肯定比不过主内存。所以 cpu 执行一个代码块（单元）时，一般先从主内存读取数据拷贝到高速缓存里，之后就是 cpu 读写高速缓存了，然后适时的将高速缓存里的数据刷写到主内存中。由此看出从硬件层面上，为了提高性能，就无法避免的有类似缓冲、数据同步的概念。有数据同步就不可避免地有数据一致性问题了。

`java` 等高级语言为了避免我们太操心这些事情，设计实现了很多概念。运行时内存区域（堆栈、方法区...）， 这些语言的编译器也都有高度封装的内存模型，负责线程间通信同步，保证线程数据同步、隔离等等。在用这些高级语言编程时，cpu 高速缓存与主内存如何通信对我们来说是透明的，基本不需要去了解，大大简化了编码的复杂程度。

### 算法操作，原子性

内存区域、内存模型只是为了更容易的并发编程踏出的第一步。现在让我们暂时抛开引用类型、值类型、堆栈、内存模型、**指令重排**等知识，假设代码中不论何时获取变量，都是直接去物理内存中拿实时数据，**不考虑性能**，类似于数据库的**读未提交**事务级别、`java` 的 `volatile` 关键字。这种情况下，所有的线程的数据读写是实时同步的，可以保证所有线程共享数据的一致性。这样能解决线程安全问题吗？不行，因为代码不只有数据，还有算法（指令与逻辑）。

这就和一个耳熟能详的特性——「**原子性**」有关了，看一个简单例子就能知道数据一致性不能完全解决线程安全问题的原因。

```kotlin
lateinit var flag: Boolean

// run in A Thread
fun aThread {
    flag = true
    printLn("just do someting and then")
    if(flag) {
	    printLn("when can i do ?")
	}
}

// run in B Thread
fun bThread {
	flag = false
}
```

假设 `aThread` 与 `bTread` 并发执行。先执行到了 `aThread` 的 `just do something and then`，这时触发中断，`bThread` 抢到控制权开始执行，将 `flag` 设为 `false`。导致 `aThread` 本该执行的 `when can i do` 跑不了。

可以看出 `flag` 数据是一致性了，但算法交替运行还是会发生问题。怎么解决例子中的问题？我们需要让 `aThread` 的执行不可被打断。即要么一次执行完 `aThread` 这个方法，要么就不要执行。这个特性就是**原子性**了，叫这个名字是因为不可打断的操作和原子不可分割的特性很像。

### 合适的“同步”

说好的并发呢，怎么扯起同步来了 👿️”。没办法，要想实现原子性，只能靠一些手段，这些手段会造成同步的效果，`java` 作者在他的书中写过：

> 如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复该问题：
>
> - 不在线程之间共享该状态变量
> - 将该状态变量修改为不可变的变量
> - 再访问该状态变量时使用同步

第一种办法属于一刀切，很有效但适用度不高。第二种属于函数式编程思想，设计使用起来不比并发编程简单。第三种就是有不可分割特性的同步操作了。实现形式上的原子性，一般就是锁了。不过不聊锁，先聊聊异步回调。

## 调度器、迭代器

## IO 模型之非阻塞

##

## 实现

## 参考

- [并发之痛 Thread，Goroutine，Actor](https://jolestar.com/parallel-programming-model-thread-goroutine-actor/)
