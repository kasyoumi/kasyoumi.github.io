---
title: 我的数据库优化手法果然有问题
date: 2023-02-07
tags: [database,数据库]
categories: 知识
toc: true
mathjax: true
author: zonowry
description: "身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一些数据库优化相关的知识点，意识流的简单聊一下吧。（阅读本文最好有一些多线程编程经验"
---

## 前言
 
 身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一些数据库优化相关的知识点，意识流的简单聊一下吧。（阅读本文最好有一些多线程编程经验
 
>[!TIPS]
>
>下文中提到的一些场景与优化，仅仅是为了方便理解乱想的例子。实际开发中还是以自身业务场景触发为好，毕竟：「过早的优化是万恶之源」
>


## 数据库知识点


### 数据库锁

讲到为什么需要锁，因为多线程场景下并发操作同一个数据（变量）时会导致线程安全问题，要想解决此类问题就需要一种”**锁**“机制。于是数据库根据颗粒度划分出**行级锁**、**页级锁**、**表级锁**。这些锁顾名思义就很容易理解了。根据行为来说的话又有**共享锁**和**互斥锁**。共享锁能够将数据设为只读，任一线程都可以读（共享数据），不过任一线程企图更新数据时都会被阻塞，直到共享锁释放。互斥锁则是为了保障写入数据的一致性，表现形式就是其它线程无法再对次数据添加任何锁。只有持有互斥锁的线程对该数据可读可写。

结合一个并发的先读后写的场景的业务场景。比如支付订单减少库存。a 用户 和 b 用户同时了购买同一个商品，且同时支付成功。我们的业务逻辑是，首先为了保险，需要判断库存是否还有剩余，如果有剩余，就减少商品库存。

```sql
-- upodate 语句会自动请求互斥锁（锁定需要的数据）
update product set stock = stock - 1 where product_id = x and stock > 0;
```

这句 sql 利用了互斥锁，保证数据的一致性。但如果放在日经问题 - 抢购业务上来看，同时上万个用户进行秒杀，数据一致性是没问题。但由于竞争互斥锁会出现阻塞，那响应速度可想而知。且数据库链接是昂贵的资源，小鸡承受不住呀。

这时候我们想到将 `stock` 这个变量做下缓存。当然，缓存那边怎么去实现，就牵扯到更多的设计了。一般是缓存好（预热/懒加载）数据，在缓存中原子性的更改缓存数据（库存）。然后在某个时间点进行一次简单地数据库更新写入，保证缓存与数据库的一致性。

```sql
update product set stock = #{stock_from_cache} where product_id = x
```

可以看出如果事先了解数据库锁的一点知识，就能避免很多类似的性能问题啦。

### 数据库索引结构

可能会首先联想到 `HashMap` 和 `Array`，它们的 **键值(HashCode)** 和 **元素下标(Index)** 就是其索引。数据库索引的概念（或者说出发点）也是类似的。为了提高搜索效率，避免枚举所有数据。但数据库的索引结构设计上就复杂很多了，通常采用平衡多叉树结构，也就是 `B+ Tree` 。

考虑在 1 亿条数据中，找到 id 为 4396 的数据这个场景。不使用索引的话，最差可能需要枚举1亿次才能找到。那 `B+Tree` 结构如何优化索引，考虑到有序树基本都是参考了二分法的思想，所以先从简单的二分法开始。

1 亿条数据一直对半分，最坏大概只需要 $log_2(1,0000,0000) \approx 26$ 次查询，可以看出仅仅一个平衡的二叉树（二分法）就可以指数级提升查找效率。再看 `B+ Tree` 与二叉树最大的区别就是其多叉，即底数 N 可能大于 2，也就降低了阶数。但是每阶可能需要比较 N 次，这样算下来效率好像没有比二叉树好。不过体现在数据库上是减少了磁盘 IO 次数，IO 次数相当于树的阶数。多叉树远比二叉树的阶数少，`B+ Tree` 在落盘环境下也就比二叉树的查询效率更高了。

但显而易见的一棵多叉树，工作机制类似二分法，搜索效率很高（~~那么代价是什么~~）。当我们增删数据时，需要分裂、合并叶子节点，那这棵树的结构会受到很大波动。因为树需要按照 `B+ Tree` 的规则（定义）平衡自己。所以我们常说建立索引后查询变快，但会导致插入、删除变慢。


### 聚集索引、索引组织表

`索引组织表`是根据一个索引结构来组织表，例如采用 `B+Tree` 构建索引，增删数据就需要根据 `B+Tree` 结构决定数据的存放位置。说白了就是索引结构影响了一个表的物理存储顺序。数据存储到哪个位置取决于这个索引结构。就是说找到索引，也就找到了数据。看起来就像数据和索引聚集到一起了，两者间有很强的关系。然后我们把这个索引叫做`聚集索引`，这种表结构的存储方式叫做`索引组织表`。

因为影响到是表的物理存储顺序，所以一个表只能有一个聚集索引，通常是根据主键建立的 `B+Tree` 索引。结合 `B+Tree` 的特性，在实际业务中，范围查询时尽量命中聚集索引、更新数据时尽量不更改聚集索引本身、尽量不要离散的增删数据（例如隔10条数据删一条这种）。

`MySQL` 的 `InnoDB` 存储引擎就采用聚集索引组织表。还有另一种表的组织方式叫做堆表，是根据数据插入时间来决定存储顺序（位置），从结构上来说相对简单些。`Postgres`、`MySQL(myisam)` 就支持采用堆表。

### 非聚集索引（辅助索引/二级索引）

有聚集索引，就有非聚集索引，也可叫做辅助索引，顾名思义可作辅助用。辅助索引的通常只存储了一个指向数据行存储位置的指针，以及索引列本身（作为键）。当我们通过（命中）辅助索引列查询数据时，一般情况下首先从辅助索引中找到记录的位置，这个位置上存放了数据行的指针，然后再通过数据行的指针去数据文件页上取数据。这样宏观上看共进行了两次 IO 读写，一次读取索引结构，一次读取数据页。
现在我们想根据员工年龄查询数据，但我们目前只有一个用户 ID列的聚集（主键）索引，数据库不可避免地会枚举所有数据进行筛选。这时候我们就可以根据年龄列建立一个辅助索引，数据库则会先通过年龄列辅助索引查询到符合条件的数据指针，再通过数据指针取到数据。

在**索引组织表**结构下拿到的这个数据指针就是主键（聚集索引）的值，通过主键的值再去**聚集索引**查询数据，这个过程叫做**回表**。在**堆表**结构下拿到的数据指针则是数据存放的绝对位置，且在**堆表**结构下，所有索引都是二级索引。

### 覆盖索引

覆盖索引可以改善**索引组织表**的**回表**现象，我们尽量保证查询的数据都是二级索引覆盖了的数据。这样找到二级索引就找到了所需要的所有数据，避免了再去聚集索引中查询数据。

例如我们要只想查询用户的 age 和 name，而恰好我们建立了 name 列和 age 列二级组合索引。

```sql
create index on user(age,name)
```

那我们此时应该避免写出类似

```sql
-- 可能查询到不需要的列，会触发回表
select * 
from user where age > 20 order by name

-- 例如 create_time 无法使用索引，数据库会再去聚集索引中查询取到 create_time 数据，可我们又不需要 create_time 
select name, age, create_time 
from user where age > 20 order by name
```

这种情况下就通过二级索引覆盖了要查询的所有数据，避免了回表操作。

```sql
select name, age from user where age > 20 order by name;
-- or 
select age from user where age > 20;
```


### mysql 和 postgres 的区别

个人感觉如何选择数据库，主要看数据库底层设计上的一些区别和生态吧，一些应用级别的特色功能我感觉倒不是很重要，例如 A 数据库比 B 数据库多支持个数据类型之类的，不过也说不准这个数据类型项目就是很需要。~~（倒装 1/1~~

所以来看看 Postgres 和 MySQL(InnoDB) 底层设计的区别。Postgres 和 InnoDB 主要区别就是的表组织方式不同，Postgres 采用堆表的形式，InnoDB 则采用索引表。索引表若按照主键（聚集索引）查询会更快，因为堆表则没有聚集索引，全都是二级索引，多一次 IO。但索引表在非覆盖索引下的优势就不存在了。数据离散插入时，堆表物理数据不会受影响，只需要调整索引。索引表的索引分裂会影响物理数据的存储顺序，导致插入性能大大降低。

InnoDB 采用线程模式处理多连接，能更好的利用机器内存。Postgres 采用进成模式处理多连接，资源开销更大一些，不过好像可以通过使用连接池中间件（[pgpool-II](https://www.pgpool.net/docs/pgpool-II-3.5.4/doc/pgpool-zh_cn.html)）来解决。



## 参考

- [MySQL为什么不用数组、哈希表、二叉树等数据结构作为索引呢](https://www.modb.pro/db/78756)
- [PostgreSQL与MySQL比较](http://bbs.chinaunix.net/thread-1688208-1-1.html)