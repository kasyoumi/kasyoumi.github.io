---
title: 我的数据库优化手法果然有问题
date: 2023-02-07
tags: [database,数据库]
categories: 知识
toc: true
mathjax: true
author: zonowry
description: "身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一下数据库常用知识点。每个知识点我都想了一个业务场景，结合着简单聊一下。（阅读本文最好有一些多线程编程经验"
---

## 前言
 
 身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一下数据库常用知识点。每个知识点我都想了一个业务场景，结合着简单聊一下。（阅读本文最好有一些多线程编程经验
 
>[!TIPS]
>下文中提到的一些场景与优化，仅仅是为了方便理解乱想的例子。实际开发中还是以自身业务场景触发。毕竟：
>「过早的优化是万恶之源」
>


## 数据库知识点


### 数据库锁

讲到为什么需要锁，因为多线程场景下并发操作同一个数据（变量）时会导致线程安全问题，要想解决此类问题就需要一种”**锁**“机制。于是数据库根据颗粒度划分出**行级锁**、**页级锁**、**表级锁**。这些锁顾名思义就很容易理解了。根据行为来说的话又有**共享锁**和**互斥锁**。共享锁能够将数据设为只读，任一线程都可以读（共享数据），不过任一线程企图更新数据时都会被阻塞，直到共享锁释放。互斥锁则是为了保障写入数据的一致性，表现形式就是其它线程无法再对次数据添加任何锁。只有持有互斥锁的线程对该数据可读可写。

结合一个并发的先读后写的场景的业务场景。比如支付订单减少库存。a 用户 和 b 用户同时了购买同一个商品，且同时支付成功。我们的业务逻辑是，首先为了保险，需要判断库存是否还有剩余，如果有剩余，就减少商品库存。

```sql
-- upodate 语句会自动请求互斥锁（锁定需要的数据）
update product set stock = stock - 1 where product_id = x and stock > 0;
```

这句 sql 利用了互斥锁，保证数据的一致性。但如果放在日经问题 - 抢购业务上来看，同时上万个用户进行秒杀，数据一致性是没问题。但由于竞争互斥锁会出现阻塞，那响应速度可想而知，数据库链接是昂贵的资源，小鸡承受不住呀。

这时候我们想到将 `stock` 这个变量做下缓存。当然，缓存那边怎么去实现，就牵扯到更多的设计了。一般是缓存好（预热/懒加载）数据，在缓存中原子性的更改缓存数据（库存）。然后在某个时间点进行一次简单地数据库更新写入，保证缓存与数据库的一致性。

```sql
update product set stock = #{stock_from_cache} where product_id = x
```

可以看出如果事先了解数据库锁的一点知识，就能避免很多类似的性能问题啦。

### 数据库索引结构

可能会首先联想到 `HashMap` 和 `Array`，它们的 **键值(HashCode)** 和 **元素下标(Index)** 就是其索引。数据库索引的概念（或者说出发点）也是类似的。为了提高搜索效率，避免枚举所有数据。但数据库的索引结构设计上就复杂很多了，通常采用平衡多叉树结构，也就是 `B+ Tree` 。

考虑在1亿条数据中，找到 id 为 4396 的数据，不使用索引的话，最差可能需要枚举1亿次才能找到。看看索引是如何工作的。因为有序平衡树结构本质上都是二分查找法的延伸。所以先看看二分法，1亿条数据一直对半分，最坏大概只需要 $log_2(1,0000,0000) \approx 26$ 次查询，可以看出仅仅二叉树就可以指数级提升查找效率。然后再来理解一下 `B+ Tree` ，与二叉树最大的区别就是其多叉，即底数可能大于 2。

想想一下一棵多叉树，工作机制类似二叉树，效率很高。但显而易见的，当我们增删数据时，需要分裂、合并叶子节点，那这棵树的结构波动会很大，因为树需要按照 `B+ Tree` 的规则（定义）平衡自己。所以我们常说建立索引后查询变快，但会导致插入、删除变慢。


### 聚簇索引

> TODO

### mysql 和 postgres 的区别

> TODO

## 参考

- https://www.modb.pro/db/78756