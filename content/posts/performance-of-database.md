---
title: 我的数据库优化手法果然有问题
date: 2023-02-07
tags: [database,数据库]
categories: 知识
toc: true
mathjax: true
author: zonowry
description: "身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一下数据库常用知识点。每个知识点我都想了一个业务场景，结合着简单聊一下。（阅读本文最好有一些多线程编程经验"
---

## 前言
 
 身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一下数据库常用知识点。每个知识点我都想了一个业务场景，结合着简单聊一下。（阅读本文最好有一些多线程编程经验
 
>[!TIPS]
>
>下文中提到的一些场景与优化，仅仅是为了方便理解乱想的例子。实际开发中还是以自身业务场景触发为好，毕竟：「过早的优化是万恶之源」
>


## 数据库知识点


### 数据库锁

讲到为什么需要锁，因为多线程场景下并发操作同一个数据（变量）时会导致线程安全问题，要想解决此类问题就需要一种”**锁**“机制。于是数据库根据颗粒度划分出**行级锁**、**页级锁**、**表级锁**。这些锁顾名思义就很容易理解了。根据行为来说的话又有**共享锁**和**互斥锁**。共享锁能够将数据设为只读，任一线程都可以读（共享数据），不过任一线程企图更新数据时都会被阻塞，直到共享锁释放。互斥锁则是为了保障写入数据的一致性，表现形式就是其它线程无法再对次数据添加任何锁。只有持有互斥锁的线程对该数据可读可写。

结合一个并发的先读后写的场景的业务场景。比如支付订单减少库存。a 用户 和 b 用户同时了购买同一个商品，且同时支付成功。我们的业务逻辑是，首先为了保险，需要判断库存是否还有剩余，如果有剩余，就减少商品库存。

```sql
-- upodate 语句会自动请求互斥锁（锁定需要的数据）
update product set stock = stock - 1 where product_id = x and stock > 0;
```

这句 sql 利用了互斥锁，保证数据的一致性。但如果放在日经问题 - 抢购业务上来看，同时上万个用户进行秒杀，数据一致性是没问题。但由于竞争互斥锁会出现阻塞，那响应速度可想而知。且数据库链接是昂贵的资源，小鸡承受不住呀。

这时候我们想到将 `stock` 这个变量做下缓存。当然，缓存那边怎么去实现，就牵扯到更多的设计了。一般是缓存好（预热/懒加载）数据，在缓存中原子性的更改缓存数据（库存）。然后在某个时间点进行一次简单地数据库更新写入，保证缓存与数据库的一致性。

```sql
update product set stock = #{stock_from_cache} where product_id = x
```

可以看出如果事先了解数据库锁的一点知识，就能避免很多类似的性能问题啦。

### 数据库索引结构

可能会首先联想到 `HashMap` 和 `Array`，它们的 **键值(HashCode)** 和 **元素下标(Index)** 就是其索引。数据库索引的概念（或者说出发点）也是类似的。为了提高搜索效率，避免枚举所有数据。但数据库的索引结构设计上就复杂很多了，通常采用平衡多叉树结构，也就是 `B+ Tree` 。

考虑在 1 亿条数据中，找到 id 为 4396 的数据这个场景。不使用索引的话，最差可能需要枚举1亿次才能找到。那 `B+Tree` 结构如何优化索引，考虑到有序树基本都是参考了二分法的思想，所以先从简单的二分法开始。

1 亿条数据一直对半分，最坏大概只需要 $log_2(1,0000,0000) \approx 26$ 次查询，可以看出仅仅一个平衡的二叉树（二分法）就可以指数级提升查找效率。再看 `B+ Tree` 与二叉树最大的区别就是其多叉，即底数 N 可能大于 2，也就降低了阶数。但是每阶可能需要比较 N 次，这样算下来效率好像没有比二叉树好。不过体现在数据库上是减少了磁盘 IO 次数，IO 次数相当于树的阶数。多叉树远比二叉树的阶数少，`B+ Tree` 在落盘环境下也就比二叉树的查询效率更高了。

但显而易见的一棵多叉树，工作机制类似二分法，搜索效率很高（~~那么代价是什么~~）。当我们增删数据时，需要分裂、合并叶子节点，那这棵树的结构会受到很大波动。因为树需要按照 `B+ Tree` 的规则（定义）平衡自己。所以我们常说建立索引后查询变快，但会导致插入、删除变慢。


### 聚集索引组织表

聚集索引组织表是根据索引结构来组织表，例如采用 `B+Tree` 构建索引，增删数据需要根据 `B+Tree` 决定存放位置。说白了就是聚集索引影响了一个表的物理存储顺序。数据的存储到那个位置取决于这个索引结构。看起来就像数据和索引聚集到一起了，两者间有很强的关系。

因为影响到是表的物理存储顺序，所以一个表只能有一个聚集索引，通常是主键。MySQL 的 InnDB 存储引擎就采用聚集索引组织表。

在实际业务中，范围查询时尽量命中聚集索引、更新数据时尽量不更改聚集索引本身、尽量不要离散的增删数据（例如隔10条数据删一条这种）。

### 辅助索引（非聚集索引）

> TODO

### 索引覆盖

> TODO


### ACID 特性

>TODO 

- 原子性：不会切割的
- 一致性
- 隔离性
- 持久性



### mysql 和 postgres 的区别

项目选型，肯定很重要。所以看看两个类似的数据库，应该如何选择。



## 参考

- https://www.modb.pro/db/78756