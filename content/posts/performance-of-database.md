---
title: 我的数据库优化手法果然有问题
date: 2023-01-02
tags: [database, 数据库]
categories: 知识
toc: true
author: zonowry
description: "身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一下数据库常用知识点。每个知识点我都想了一个业务场景，结合着简单聊一下。（阅读本文最好有一些多线程编程经验"
---

## 前言

身为一个后端开发，肯定都会写点数据库增删改查脚本。但牵扯到业务场景时，只会写增删改查是不太够的。优秀的数据库设计直接影响业务系统的响应速度，所以整理了一下数据库常用知识点。每个知识点我都想了一个业务场景，结合着简单聊一下。（阅读本文最好有一些多线程编程经验

> [!TIPS]
> 下文中提到的一些场景与优化，仅仅是为了方便理解乱想的例子。实际开发中还是以自身业务场景触发。毕竟：
> 「过早的优化是万恶之源」

## 数据库知识点

### 数据库锁

讲到为什么需要锁，基本是因为多线程场景下并发操作同一个数据（变量）时会导致的线程安全问题，要想解决此类问题就需要一种”**锁**“机制。数据库根据颗粒度划分出**行级锁**、**页级锁**、**表级锁**。根据行为来说的话又有**共享锁**和**互斥锁**。共享锁能够将数据设为只读，其它线程可以向更新数据时会被阻塞，直到共享锁释放。互斥锁则是为了保障写入数据的一致性，表现形式就是其它线程无法再对次数据添加任何锁。只有持有互斥锁的线程对该数据可读可写。

结合一个并发的先读后写的场景的业务场景。比如支付订单减少库存。a 用户 和 b 用户同时了购买同一个商品，且同时支付成功。我们的业务逻辑是，为了保险，需要判断库存是否还有剩余，如果有剩余，就减少商品库存。

```sql
update product set stock = stock - 1 where product_id = x and stock > 0;
```

这句 sql 利用了互斥锁，保证数据的一致性。但如果放在日经问题 - 抢购业务上来看，同时上万个用户进行秒杀，数据一致性是没问题。但由于竞争互斥锁会出现阻塞，那响应速度可想而知，数据库链接是昂贵的资源，小鸡承受不住呀。

这时候我们想到将 `stock` 这个变量做下缓存，互斥锁只用来进行在某个时间段一次简单地更新赋值。

```sql
update product set stock = #{stock_from_cache} where product_id = x
```

当然，缓存那边怎么去实现，就牵扯到更多的设计了。一般是预热+懒加载，缓存中原子性的更改库存。

事先了解数据库锁的一点知识，就能避免遇到类似的性能啦。

### 聚簇索引

### mysql 和 postgres 的区别
